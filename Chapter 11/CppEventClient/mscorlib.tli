// Created by Microsoft (R) C/C++ Compiler Version 12.00.8447.0 (bc5cac8c).
//
// mscorlib.tli
//
// Wrapper implementations for Win32 type library C:\WINDOWS\Microsoft.NET\Framework\v1.0.3617\mscorlib.tlb
// compiler-generated file created 02/09/02 at 17:22:07 - DO NOT EDIT!


//
// interface ICloneable wrapper method implementations
//

#pragma implementation_key(1)
inline _variant_t ICloneable::Clone ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Clone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IEnumerable wrapper method implementations
//

#pragma implementation_key(2)
inline IEnumVARIANTPtr IEnumerable::GetEnumerator ( ) {
    struct IEnumVARIANT * _result;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEnumVARIANTPtr(_result, false);
}

//
// interface ICollection wrapper method implementations
//

#pragma implementation_key(3)
inline HRESULT ICollection::CopyTo ( struct _Array * Array, long index ) {
    HRESULT _hr = raw_CopyTo(Array, index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4)
inline long ICollection::GetCount ( ) {
    long _result;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5)
inline _variant_t ICollection::GetSyncRoot ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_SyncRoot(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(6)
inline VARIANT_BOOL ICollection::GetIsSynchronized ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSynchronized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IList wrapper method implementations
//

#pragma implementation_key(7)
inline _variant_t IList::GetItem ( long index ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(8)
inline void IList::PutRefItem ( long index, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(index, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(9)
inline long IList::Add ( const _variant_t & value ) {
    long _result;
    HRESULT _hr = raw_Add(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(10)
inline VARIANT_BOOL IList::Contains ( const _variant_t & value ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Contains(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(11)
inline HRESULT IList::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(12)
inline VARIANT_BOOL IList::GetIsReadOnly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(13)
inline VARIANT_BOOL IList::GetIsFixedSize ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFixedSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(14)
inline long IList::IndexOf ( const _variant_t & value ) {
    long _result;
    HRESULT _hr = raw_IndexOf(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(15)
inline HRESULT IList::Insert ( long index, const _variant_t & value ) {
    HRESULT _hr = raw_Insert(index, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(16)
inline HRESULT IList::Remove ( const _variant_t & value ) {
    HRESULT _hr = raw_Remove(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(17)
inline HRESULT IList::RemoveAt ( long index ) {
    HRESULT _hr = raw_RemoveAt(index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IEnumerator wrapper method implementations
//

#pragma implementation_key(18)
inline VARIANT_BOOL IEnumerator::MoveNext ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_MoveNext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(19)
inline _variant_t IEnumerator::GetCurrent ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Current(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(20)
inline HRESULT IEnumerator::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IComparable wrapper method implementations
//

#pragma implementation_key(21)
inline long IComparable::CompareTo ( const _variant_t & obj ) {
    long _result;
    HRESULT _hr = raw_CompareTo(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IConvertible wrapper method implementations
//

#pragma implementation_key(22)
inline enum TypeCode IConvertible::GetTypeCode ( ) {
    enum TypeCode _result;
    HRESULT _hr = raw_GetTypeCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(23)
inline VARIANT_BOOL IConvertible::ToBoolean ( struct IFormatProvider * provider ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_ToBoolean(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(24)
inline unsigned short IConvertible::ToChar ( struct IFormatProvider * provider ) {
    unsigned short _result;
    HRESULT _hr = raw_ToChar(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(25)
inline char IConvertible::ToSByte ( struct IFormatProvider * provider ) {
    char _result;
    HRESULT _hr = raw_ToSByte(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(26)
inline unsigned char IConvertible::ToByte ( struct IFormatProvider * provider ) {
    unsigned char _result;
    HRESULT _hr = raw_ToByte(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(27)
inline short IConvertible::ToInt16 ( struct IFormatProvider * provider ) {
    short _result;
    HRESULT _hr = raw_ToInt16(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(28)
inline unsigned short IConvertible::ToUInt16 ( struct IFormatProvider * provider ) {
    unsigned short _result;
    HRESULT _hr = raw_ToUInt16(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(29)
inline long IConvertible::ToInt32 ( struct IFormatProvider * provider ) {
    long _result;
    HRESULT _hr = raw_ToInt32(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(30)
inline unsigned long IConvertible::ToUInt32 ( struct IFormatProvider * provider ) {
    unsigned long _result;
    HRESULT _hr = raw_ToUInt32(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(31)
inline __int64 IConvertible::ToInt64 ( struct IFormatProvider * provider ) {
    __int64 _result;
    HRESULT _hr = raw_ToInt64(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(32)
inline unsigned __int64 IConvertible::ToUInt64 ( struct IFormatProvider * provider ) {
    unsigned __int64 _result;
    HRESULT _hr = raw_ToUInt64(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(33)
inline float IConvertible::ToSingle ( struct IFormatProvider * provider ) {
    float _result;
    HRESULT _hr = raw_ToSingle(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(34)
inline double IConvertible::ToDouble ( struct IFormatProvider * provider ) {
    double _result;
    HRESULT _hr = raw_ToDouble(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(35)
inline DECIMAL IConvertible::ToDecimal ( struct IFormatProvider * provider ) {
    DECIMAL _result;
    HRESULT _hr = raw_ToDecimal(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(36)
inline DATE IConvertible::ToDateTime ( struct IFormatProvider * provider ) {
    DATE _result;
    HRESULT _hr = raw_ToDateTime(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(37)
inline _bstr_t IConvertible::GetToString ( struct IFormatProvider * provider ) {
    BSTR _result;
    HRESULT _hr = get_ToString(provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(38)
inline _variant_t IConvertible::ToType ( struct _Type * conversionType, struct IFormatProvider * provider ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_ToType(conversionType, provider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ISerializable wrapper method implementations
//

#pragma implementation_key(39)
inline HRESULT ISerializable::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IFormattable wrapper method implementations
//

#pragma implementation_key(40)
inline _bstr_t IFormattable::GetToString ( _bstr_t format, struct IFormatProvider * formatProvider ) {
    BSTR _result;
    HRESULT _hr = get_ToString(format, formatProvider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _AppDomain wrapper method implementations
//

#pragma implementation_key(41)
inline _bstr_t _AppDomain::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(42)
inline VARIANT_BOOL _AppDomain::Equals ( const _variant_t & other ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(other, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(43)
inline long _AppDomain::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(44)
inline _TypePtr _AppDomain::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(45)
inline _variant_t _AppDomain::InitializeLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InitializeLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(46)
inline _variant_t _AppDomain::GetLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(47)
inline _EvidencePtr _AppDomain::GetEvidence ( ) {
    struct _Evidence * _result;
    HRESULT _hr = get_Evidence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EvidencePtr(_result, false);
}

#pragma implementation_key(48)
inline HRESULT _AppDomain::add_DomainUnload ( struct _EventHandler * value ) {
    HRESULT _hr = raw_add_DomainUnload(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(49)
inline HRESULT _AppDomain::remove_DomainUnload ( struct _EventHandler * value ) {
    HRESULT _hr = raw_remove_DomainUnload(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(50)
inline HRESULT _AppDomain::add_AssemblyLoad ( struct _AssemblyLoadEventHandler * value ) {
    HRESULT _hr = raw_add_AssemblyLoad(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(51)
inline HRESULT _AppDomain::remove_AssemblyLoad ( struct _AssemblyLoadEventHandler * value ) {
    HRESULT _hr = raw_remove_AssemblyLoad(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(52)
inline HRESULT _AppDomain::add_ProcessExit ( struct _EventHandler * value ) {
    HRESULT _hr = raw_add_ProcessExit(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(53)
inline HRESULT _AppDomain::remove_ProcessExit ( struct _EventHandler * value ) {
    HRESULT _hr = raw_remove_ProcessExit(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(54)
inline HRESULT _AppDomain::add_TypeResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_add_TypeResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(55)
inline HRESULT _AppDomain::remove_TypeResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_TypeResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(56)
inline HRESULT _AppDomain::add_ResourceResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_add_ResourceResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(57)
inline HRESULT _AppDomain::remove_ResourceResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_ResourceResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(58)
inline HRESULT _AppDomain::add_AssemblyResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_add_AssemblyResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(59)
inline HRESULT _AppDomain::remove_AssemblyResolve ( struct _ResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_AssemblyResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(60)
inline HRESULT _AppDomain::add_UnhandledException ( struct _UnhandledExceptionEventHandler * value ) {
    HRESULT _hr = raw_add_UnhandledException(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(61)
inline HRESULT _AppDomain::remove_UnhandledException ( struct _UnhandledExceptionEventHandler * value ) {
    HRESULT _hr = raw_remove_UnhandledException(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(62)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly ( struct _AssemblyName * name, enum AssemblyBuilderAccess access ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly(name, access, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(63)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_2 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_2(name, access, dir, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(64)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_3 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, struct _Evidence * Evidence ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_3(name, access, Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(65)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_4 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_4(name, access, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(66)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_5 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _Evidence * Evidence ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_5(name, access, dir, Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(67)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_6 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_6(name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(68)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_7 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, struct _Evidence * Evidence, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_7(name, access, Evidence, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(69)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_8 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _Evidence * Evidence, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_8(name, access, dir, Evidence, requiredPermissions, optionalPermissions, refusedPermissions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(70)
inline _AssemblyBuilderPtr _AppDomain::DefineDynamicAssembly_9 ( struct _AssemblyName * name, enum AssemblyBuilderAccess access, _bstr_t dir, struct _Evidence * Evidence, struct _PermissionSet * requiredPermissions, struct _PermissionSet * optionalPermissions, struct _PermissionSet * refusedPermissions, VARIANT_BOOL IsSynchronized ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_DefineDynamicAssembly_9(name, access, dir, Evidence, requiredPermissions, optionalPermissions, refusedPermissions, IsSynchronized, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(71)
inline _ObjectHandlePtr _AppDomain::CreateInstance ( _bstr_t AssemblyName, _bstr_t typeName ) {
    struct _ObjectHandle * _result;
    HRESULT _hr = raw_CreateInstance(AssemblyName, typeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

#pragma implementation_key(72)
inline _ObjectHandlePtr _AppDomain::CreateInstanceFrom ( _bstr_t assemblyFile, _bstr_t typeName ) {
    struct _ObjectHandle * _result;
    HRESULT _hr = raw_CreateInstanceFrom(assemblyFile, typeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

#pragma implementation_key(73)
inline _ObjectHandlePtr _AppDomain::CreateInstance_2 ( _bstr_t AssemblyName, _bstr_t typeName, SAFEARRAY * activationAttributes ) {
    struct _ObjectHandle * _result;
    HRESULT _hr = raw_CreateInstance_2(AssemblyName, typeName, activationAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

#pragma implementation_key(74)
inline _ObjectHandlePtr _AppDomain::CreateInstanceFrom_2 ( _bstr_t assemblyFile, _bstr_t typeName, SAFEARRAY * activationAttributes ) {
    struct _ObjectHandle * _result;
    HRESULT _hr = raw_CreateInstanceFrom_2(assemblyFile, typeName, activationAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

#pragma implementation_key(75)
inline _ObjectHandlePtr _AppDomain::CreateInstance_3 ( _bstr_t AssemblyName, _bstr_t typeName, VARIANT_BOOL ignoreCase, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * args, struct _CultureInfo * culture, SAFEARRAY * activationAttributes, struct _Evidence * securityAttributes ) {
    struct _ObjectHandle * _result;
    HRESULT _hr = raw_CreateInstance_3(AssemblyName, typeName, ignoreCase, bindingAttr, Binder, args, culture, activationAttributes, securityAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

#pragma implementation_key(76)
inline _ObjectHandlePtr _AppDomain::CreateInstanceFrom_3 ( _bstr_t assemblyFile, _bstr_t typeName, VARIANT_BOOL ignoreCase, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * args, struct _CultureInfo * culture, SAFEARRAY * activationAttributes, struct _Evidence * securityAttributes ) {
    struct _ObjectHandle * _result;
    HRESULT _hr = raw_CreateInstanceFrom_3(assemblyFile, typeName, ignoreCase, bindingAttr, Binder, args, culture, activationAttributes, securityAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjectHandlePtr(_result, false);
}

#pragma implementation_key(77)
inline _AssemblyPtr _AppDomain::Load ( struct _AssemblyName * assemblyRef ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_Load(assemblyRef, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(78)
inline _AssemblyPtr _AppDomain::Load_2 ( _bstr_t assemblyString ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_Load_2(assemblyString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(79)
inline _AssemblyPtr _AppDomain::Load_3 ( SAFEARRAY * rawAssembly ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_Load_3(rawAssembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(80)
inline _AssemblyPtr _AppDomain::Load_4 ( SAFEARRAY * rawAssembly, SAFEARRAY * rawSymbolStore ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_Load_4(rawAssembly, rawSymbolStore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(81)
inline _AssemblyPtr _AppDomain::Load_5 ( SAFEARRAY * rawAssembly, SAFEARRAY * rawSymbolStore, struct _Evidence * securityEvidence ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_Load_5(rawAssembly, rawSymbolStore, securityEvidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(82)
inline _AssemblyPtr _AppDomain::Load_6 ( struct _AssemblyName * assemblyRef, struct _Evidence * assemblySecurity ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_Load_6(assemblyRef, assemblySecurity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(83)
inline _AssemblyPtr _AppDomain::Load_7 ( _bstr_t assemblyString, struct _Evidence * assemblySecurity ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_Load_7(assemblyString, assemblySecurity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(84)
inline long _AppDomain::ExecuteAssembly ( _bstr_t assemblyFile, struct _Evidence * assemblySecurity ) {
    long _result;
    HRESULT _hr = raw_ExecuteAssembly(assemblyFile, assemblySecurity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(85)
inline long _AppDomain::ExecuteAssembly_2 ( _bstr_t assemblyFile ) {
    long _result;
    HRESULT _hr = raw_ExecuteAssembly_2(assemblyFile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(86)
inline long _AppDomain::ExecuteAssembly_3 ( _bstr_t assemblyFile, struct _Evidence * assemblySecurity, SAFEARRAY * args ) {
    long _result;
    HRESULT _hr = raw_ExecuteAssembly_3(assemblyFile, assemblySecurity, args, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(87)
inline _bstr_t _AppDomain::GetFriendlyName ( ) {
    BSTR _result;
    HRESULT _hr = get_FriendlyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(88)
inline _bstr_t _AppDomain::GetBaseDirectory ( ) {
    BSTR _result;
    HRESULT _hr = get_BaseDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(89)
inline _bstr_t _AppDomain::GetRelativeSearchPath ( ) {
    BSTR _result;
    HRESULT _hr = get_RelativeSearchPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(90)
inline VARIANT_BOOL _AppDomain::GetShadowCopyFiles ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_ShadowCopyFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(91)
inline SAFEARRAY * _AppDomain::GetAssemblies ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetAssemblies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(92)
inline HRESULT _AppDomain::AppendPrivatePath ( _bstr_t Path ) {
    HRESULT _hr = raw_AppendPrivatePath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(93)
inline HRESULT _AppDomain::ClearPrivatePath ( ) {
    HRESULT _hr = raw_ClearPrivatePath();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(94)
inline HRESULT _AppDomain::SetShadowCopyPath ( _bstr_t s ) {
    HRESULT _hr = raw_SetShadowCopyPath(s);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(95)
inline HRESULT _AppDomain::ClearShadowCopyPath ( ) {
    HRESULT _hr = raw_ClearShadowCopyPath();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(96)
inline HRESULT _AppDomain::SetCachePath ( _bstr_t s ) {
    HRESULT _hr = raw_SetCachePath(s);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(97)
inline HRESULT _AppDomain::SetData ( _bstr_t name, const _variant_t & data ) {
    HRESULT _hr = raw_SetData(name, data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(98)
inline _variant_t _AppDomain::GetData ( _bstr_t name ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetData(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(99)
inline HRESULT _AppDomain::SetAppDomainPolicy ( struct _PolicyLevel * domainPolicy ) {
    HRESULT _hr = raw_SetAppDomainPolicy(domainPolicy);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(100)
inline HRESULT _AppDomain::SetThreadPrincipal ( struct IPrincipal * principal ) {
    HRESULT _hr = raw_SetThreadPrincipal(principal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(101)
inline HRESULT _AppDomain::SetPrincipalPolicy ( enum PrincipalPolicy policy ) {
    HRESULT _hr = raw_SetPrincipalPolicy(policy);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(102)
inline HRESULT _AppDomain::DoCallBack ( struct _CrossAppDomainDelegate * theDelegate ) {
    HRESULT _hr = raw_DoCallBack(theDelegate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(103)
inline _bstr_t _AppDomain::GetDynamicDirectory ( ) {
    BSTR _result;
    HRESULT _hr = get_DynamicDirectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IEvidenceFactory wrapper method implementations
//

#pragma implementation_key(104)
inline _EvidencePtr IEvidenceFactory::GetEvidence ( ) {
    struct _Evidence * _result;
    HRESULT _hr = get_Evidence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EvidencePtr(_result, false);
}

//
// interface IAppDomainSetup wrapper method implementations
//

#pragma implementation_key(105)
inline _bstr_t IAppDomainSetup::GetApplicationBase ( ) {
    BSTR _result;
    HRESULT _hr = get_ApplicationBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(106)
inline void IAppDomainSetup::PutApplicationBase ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ApplicationBase(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(107)
inline _bstr_t IAppDomainSetup::GetApplicationName ( ) {
    BSTR _result;
    HRESULT _hr = get_ApplicationName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(108)
inline void IAppDomainSetup::PutApplicationName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ApplicationName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(109)
inline _bstr_t IAppDomainSetup::GetCachePath ( ) {
    BSTR _result;
    HRESULT _hr = get_CachePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(110)
inline void IAppDomainSetup::PutCachePath ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CachePath(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(111)
inline _bstr_t IAppDomainSetup::GetConfigurationFile ( ) {
    BSTR _result;
    HRESULT _hr = get_ConfigurationFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(112)
inline void IAppDomainSetup::PutConfigurationFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ConfigurationFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(113)
inline _bstr_t IAppDomainSetup::GetDynamicBase ( ) {
    BSTR _result;
    HRESULT _hr = get_DynamicBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(114)
inline void IAppDomainSetup::PutDynamicBase ( _bstr_t pRetVal ) {
    HRESULT _hr = put_DynamicBase(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(115)
inline _bstr_t IAppDomainSetup::GetLicenseFile ( ) {
    BSTR _result;
    HRESULT _hr = get_LicenseFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(116)
inline void IAppDomainSetup::PutLicenseFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LicenseFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(117)
inline _bstr_t IAppDomainSetup::GetPrivateBinPath ( ) {
    BSTR _result;
    HRESULT _hr = get_PrivateBinPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(118)
inline void IAppDomainSetup::PutPrivateBinPath ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PrivateBinPath(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(119)
inline _bstr_t IAppDomainSetup::GetPrivateBinPathProbe ( ) {
    BSTR _result;
    HRESULT _hr = get_PrivateBinPathProbe(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(120)
inline void IAppDomainSetup::PutPrivateBinPathProbe ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PrivateBinPathProbe(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(121)
inline _bstr_t IAppDomainSetup::GetShadowCopyDirectories ( ) {
    BSTR _result;
    HRESULT _hr = get_ShadowCopyDirectories(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(122)
inline void IAppDomainSetup::PutShadowCopyDirectories ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ShadowCopyDirectories(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(123)
inline _bstr_t IAppDomainSetup::GetShadowCopyFiles ( ) {
    BSTR _result;
    HRESULT _hr = get_ShadowCopyFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(124)
inline void IAppDomainSetup::PutShadowCopyFiles ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ShadowCopyFiles(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IObjectReference wrapper method implementations
//

#pragma implementation_key(125)
inline _variant_t IObjectReference::GetRealObject ( struct StreamingContext Context ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetRealObject(Context, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAsyncResult wrapper method implementations
//

#pragma implementation_key(126)
inline VARIANT_BOOL IAsyncResult::GetIsCompleted ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsCompleted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(127)
inline _WaitHandlePtr IAsyncResult::GetAsyncWaitHandle ( ) {
    struct _WaitHandle * _result;
    HRESULT _hr = get_AsyncWaitHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _WaitHandlePtr(_result, false);
}

#pragma implementation_key(128)
inline _variant_t IAsyncResult::GetAsyncState ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_AsyncState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(129)
inline VARIANT_BOOL IAsyncResult::GetCompletedSynchronously ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_CompletedSynchronously(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICustomFormatter wrapper method implementations
//

#pragma implementation_key(130)
inline _bstr_t ICustomFormatter::format ( _bstr_t format, const _variant_t & arg, struct IFormatProvider * formatProvider ) {
    BSTR _result;
    HRESULT _hr = raw_format(format, arg, formatProvider, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IDisposable wrapper method implementations
//

#pragma implementation_key(131)
inline HRESULT IDisposable::Dispose ( ) {
    HRESULT _hr = raw_Dispose();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IFormatProvider wrapper method implementations
//

#pragma implementation_key(132)
inline _variant_t IFormatProvider::GetFormat ( struct _Type * formatType ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetFormat(formatType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ICustomAttributeProvider wrapper method implementations
//

#pragma implementation_key(133)
inline SAFEARRAY * ICustomAttributeProvider::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(134)
inline SAFEARRAY * ICustomAttributeProvider::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(135)
inline VARIANT_BOOL ICustomAttributeProvider::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IReflect wrapper method implementations
//

#pragma implementation_key(136)
inline _MethodInfoPtr IReflect::GetMethod ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod(name, bindingAttr, Binder, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(137)
inline _MethodInfoPtr IReflect::GetMethod_2 ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod_2(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(138)
inline SAFEARRAY * IReflect::GetMethods ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMethods(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(139)
inline _FieldInfoPtr IReflect::GetField ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _FieldInfo * _result;
    HRESULT _hr = raw_GetField(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

#pragma implementation_key(140)
inline SAFEARRAY * IReflect::GetFields ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetFields(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(141)
inline _PropertyInfoPtr IReflect::GetProperty ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(142)
inline _PropertyInfoPtr IReflect::GetProperty_2 ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, struct _Type * returnType, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty_2(name, bindingAttr, Binder, returnType, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(143)
inline SAFEARRAY * IReflect::GetProperties ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetProperties(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(144)
inline SAFEARRAY * IReflect::GetMember ( _bstr_t name, enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMember(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(145)
inline SAFEARRAY * IReflect::GetMembers ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMembers(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(146)
inline _variant_t IReflect::InvokeMember ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args, SAFEARRAY * modifiers, struct _CultureInfo * culture, SAFEARRAY * namedParameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember(name, invokeAttr, Binder, Target, args, modifiers, culture, namedParameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(147)
inline _TypePtr IReflect::GetUnderlyingSystemType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_UnderlyingSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

//
// interface IObjectHandle wrapper method implementations
//

#pragma implementation_key(148)
inline _variant_t IObjectHandle::Unwrap ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Unwrap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IComparer wrapper method implementations
//

#pragma implementation_key(149)
inline long IComparer::Compare ( const _variant_t & x, const _variant_t & y ) {
    long _result;
    HRESULT _hr = raw_Compare(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IHashCodeProvider wrapper method implementations
//

#pragma implementation_key(150)
inline long IHashCodeProvider::GetHashCode ( const _variant_t & obj ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IDictionary wrapper method implementations
//

#pragma implementation_key(151)
inline _variant_t IDictionary::GetItem ( const _variant_t & key ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(152)
inline void IDictionary::PutRefItem ( const _variant_t & key, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(key, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(153)
inline ICollectionPtr IDictionary::GetKeys ( ) {
    struct ICollection * _result;
    HRESULT _hr = get_Keys(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICollectionPtr(_result, false);
}

#pragma implementation_key(154)
inline ICollectionPtr IDictionary::GetValues ( ) {
    struct ICollection * _result;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICollectionPtr(_result, false);
}

#pragma implementation_key(155)
inline VARIANT_BOOL IDictionary::Contains ( const _variant_t & key ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Contains(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(156)
inline HRESULT IDictionary::Add ( const _variant_t & key, const _variant_t & value ) {
    HRESULT _hr = raw_Add(key, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(157)
inline HRESULT IDictionary::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(158)
inline VARIANT_BOOL IDictionary::GetIsReadOnly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(159)
inline VARIANT_BOOL IDictionary::GetIsFixedSize ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFixedSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(160)
inline IDictionaryEnumeratorPtr IDictionary::GetEnumerator ( ) {
    struct IDictionaryEnumerator * _result;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryEnumeratorPtr(_result, false);
}

#pragma implementation_key(161)
inline HRESULT IDictionary::Remove ( const _variant_t & key ) {
    HRESULT _hr = raw_Remove(key);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDeserializationCallback wrapper method implementations
//

#pragma implementation_key(162)
inline HRESULT IDeserializationCallback::OnDeserialization ( const _variant_t & sender ) {
    HRESULT _hr = raw_OnDeserialization(sender);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDictionaryEnumerator wrapper method implementations
//

#pragma implementation_key(163)
inline _variant_t IDictionaryEnumerator::Getkey ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_key(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(164)
inline _variant_t IDictionaryEnumerator::Getvalue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(165)
inline struct DictionaryEntry IDictionaryEnumerator::GetEntry ( ) {
    struct DictionaryEntry _result;
    HRESULT _hr = get_Entry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolBinder wrapper method implementations
//

#pragma implementation_key(166)
inline ISymbolReaderPtr ISymbolBinder::GetReader ( long importer, _bstr_t filename, _bstr_t searchPath ) {
    struct ISymbolReader * _result;
    HRESULT _hr = raw_GetReader(importer, filename, searchPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolReaderPtr(_result, false);
}

//
// interface ISymbolDocument wrapper method implementations
//

#pragma implementation_key(167)
inline _bstr_t ISymbolDocument::GetUrl ( ) {
    BSTR _result;
    HRESULT _hr = get_Url(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(168)
inline GUID ISymbolDocument::GetDocumentType ( ) {
    GUID _result;
    HRESULT _hr = get_DocumentType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(169)
inline GUID ISymbolDocument::GetLanguage ( ) {
    GUID _result;
    HRESULT _hr = get_Language(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(170)
inline GUID ISymbolDocument::GetLanguageVendor ( ) {
    GUID _result;
    HRESULT _hr = get_LanguageVendor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(171)
inline GUID ISymbolDocument::GetCheckSumAlgorithmId ( ) {
    GUID _result;
    HRESULT _hr = get_CheckSumAlgorithmId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(172)
inline SAFEARRAY * ISymbolDocument::GetCheckSum ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCheckSum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(173)
inline long ISymbolDocument::FindClosestLine ( long line ) {
    long _result;
    HRESULT _hr = raw_FindClosestLine(line, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(174)
inline VARIANT_BOOL ISymbolDocument::GetHasEmbeddedSource ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_HasEmbeddedSource(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(175)
inline long ISymbolDocument::GetSourceLength ( ) {
    long _result;
    HRESULT _hr = get_SourceLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(176)
inline SAFEARRAY * ISymbolDocument::GetSourceRange ( long startLine, long startColumn, long endLine, long endColumn ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetSourceRange(startLine, startColumn, endLine, endColumn, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolDocumentWriter wrapper method implementations
//

#pragma implementation_key(177)
inline HRESULT ISymbolDocumentWriter::SetSource ( SAFEARRAY * Source ) {
    HRESULT _hr = raw_SetSource(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(178)
inline HRESULT ISymbolDocumentWriter::SetCheckSum ( GUID algorithmId, SAFEARRAY * checkSum ) {
    HRESULT _hr = raw_SetCheckSum(algorithmId, checkSum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISymbolMethod wrapper method implementations
//

#pragma implementation_key(179)
inline struct SymbolToken ISymbolMethod::GetToken ( ) {
    struct SymbolToken _result;
    HRESULT _hr = get_Token(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(180)
inline long ISymbolMethod::GetSequencePointCount ( ) {
    long _result;
    HRESULT _hr = get_SequencePointCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(181)
inline HRESULT ISymbolMethod::GetSequencePoints ( SAFEARRAY * offsets, SAFEARRAY * documents, SAFEARRAY * lines, SAFEARRAY * columns, SAFEARRAY * endLines, SAFEARRAY * endColumns ) {
    HRESULT _hr = raw_GetSequencePoints(offsets, documents, lines, columns, endLines, endColumns);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(182)
inline ISymbolScopePtr ISymbolMethod::GetRootScope ( ) {
    struct ISymbolScope * _result;
    HRESULT _hr = get_RootScope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolScopePtr(_result, false);
}

#pragma implementation_key(183)
inline ISymbolScopePtr ISymbolMethod::GetScope ( long offset ) {
    struct ISymbolScope * _result;
    HRESULT _hr = raw_GetScope(offset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolScopePtr(_result, false);
}

#pragma implementation_key(184)
inline long ISymbolMethod::GetOffset ( struct ISymbolDocument * document, long line, long column ) {
    long _result;
    HRESULT _hr = raw_GetOffset(document, line, column, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(185)
inline SAFEARRAY * ISymbolMethod::GetRanges ( struct ISymbolDocument * document, long line, long column ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetRanges(document, line, column, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(186)
inline SAFEARRAY * ISymbolMethod::GetParameters ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(187)
inline ISymbolNamespacePtr ISymbolMethod::GetNamespace ( ) {
    struct ISymbolNamespace * _result;
    HRESULT _hr = raw_GetNamespace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolNamespacePtr(_result, false);
}

#pragma implementation_key(188)
inline VARIANT_BOOL ISymbolMethod::GetSourceStartEnd ( SAFEARRAY * docs, SAFEARRAY * lines, SAFEARRAY * columns ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_GetSourceStartEnd(docs, lines, columns, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolNamespace wrapper method implementations
//

#pragma implementation_key(189)
inline _bstr_t ISymbolNamespace::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(190)
inline SAFEARRAY * ISymbolNamespace::GetNamespaces ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetNamespaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(191)
inline SAFEARRAY * ISymbolNamespace::GetVariables ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetVariables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolReader wrapper method implementations
//

#pragma implementation_key(192)
inline ISymbolDocumentPtr ISymbolReader::GetDocument ( _bstr_t Url, GUID Language, GUID LanguageVendor, GUID DocumentType ) {
    struct ISymbolDocument * _result;
    HRESULT _hr = raw_GetDocument(Url, Language, LanguageVendor, DocumentType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolDocumentPtr(_result, false);
}

#pragma implementation_key(193)
inline SAFEARRAY * ISymbolReader::GetDocuments ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetDocuments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(194)
inline struct SymbolToken ISymbolReader::GetUserEntryPoint ( ) {
    struct SymbolToken _result;
    HRESULT _hr = get_UserEntryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(195)
inline ISymbolMethodPtr ISymbolReader::GetMethod ( struct SymbolToken Method ) {
    struct ISymbolMethod * _result;
    HRESULT _hr = raw_GetMethod(Method, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

#pragma implementation_key(196)
inline ISymbolMethodPtr ISymbolReader::GetMethod_2 ( struct SymbolToken Method, long Version ) {
    struct ISymbolMethod * _result;
    HRESULT _hr = raw_GetMethod_2(Method, Version, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

#pragma implementation_key(197)
inline SAFEARRAY * ISymbolReader::GetVariables ( struct SymbolToken parent ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetVariables(parent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(198)
inline SAFEARRAY * ISymbolReader::GetGlobalVariables ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetGlobalVariables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(199)
inline ISymbolMethodPtr ISymbolReader::GetMethodFromDocumentPosition ( struct ISymbolDocument * document, long line, long column ) {
    struct ISymbolMethod * _result;
    HRESULT _hr = raw_GetMethodFromDocumentPosition(document, line, column, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

#pragma implementation_key(200)
inline SAFEARRAY * ISymbolReader::GetSymAttribute ( struct SymbolToken parent, _bstr_t name ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetSymAttribute(parent, name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(201)
inline SAFEARRAY * ISymbolReader::GetNamespaces ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetNamespaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolScope wrapper method implementations
//

#pragma implementation_key(202)
inline ISymbolMethodPtr ISymbolScope::GetMethod ( ) {
    struct ISymbolMethod * _result;
    HRESULT _hr = get_Method(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolMethodPtr(_result, false);
}

#pragma implementation_key(203)
inline ISymbolScopePtr ISymbolScope::Getparent ( ) {
    struct ISymbolScope * _result;
    HRESULT _hr = get_parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolScopePtr(_result, false);
}

#pragma implementation_key(204)
inline SAFEARRAY * ISymbolScope::GetChildren ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetChildren(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(205)
inline long ISymbolScope::GetStartOffset ( ) {
    long _result;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(206)
inline long ISymbolScope::GetEndOffset ( ) {
    long _result;
    HRESULT _hr = get_EndOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(207)
inline SAFEARRAY * ISymbolScope::GetLocals ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetLocals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(208)
inline SAFEARRAY * ISymbolScope::GetNamespaces ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetNamespaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolVariable wrapper method implementations
//

#pragma implementation_key(209)
inline _bstr_t ISymbolVariable::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(210)
inline _variant_t ISymbolVariable::GetAttributes ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(211)
inline SAFEARRAY * ISymbolVariable::GetSignature ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetSignature(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(212)
inline enum SymAddressKind ISymbolVariable::GetAddressKind ( ) {
    enum SymAddressKind _result;
    HRESULT _hr = get_AddressKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(213)
inline long ISymbolVariable::GetAddressField1 ( ) {
    long _result;
    HRESULT _hr = get_AddressField1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(214)
inline long ISymbolVariable::GetAddressField2 ( ) {
    long _result;
    HRESULT _hr = get_AddressField2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(215)
inline long ISymbolVariable::GetAddressField3 ( ) {
    long _result;
    HRESULT _hr = get_AddressField3(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(216)
inline long ISymbolVariable::GetStartOffset ( ) {
    long _result;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(217)
inline long ISymbolVariable::GetEndOffset ( ) {
    long _result;
    HRESULT _hr = get_EndOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISymbolWriter wrapper method implementations
//

#pragma implementation_key(218)
inline HRESULT ISymbolWriter::Initialize ( long emitter, _bstr_t filename, VARIANT_BOOL fFullBuild ) {
    HRESULT _hr = raw_Initialize(emitter, filename, fFullBuild);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(219)
inline ISymbolDocumentWriterPtr ISymbolWriter::DefineDocument ( _bstr_t Url, GUID Language, GUID LanguageVendor, GUID DocumentType ) {
    struct ISymbolDocumentWriter * _result;
    HRESULT _hr = raw_DefineDocument(Url, Language, LanguageVendor, DocumentType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISymbolDocumentWriterPtr(_result, false);
}

#pragma implementation_key(220)
inline HRESULT ISymbolWriter::SetUserEntryPoint ( struct SymbolToken entryMethod ) {
    HRESULT _hr = raw_SetUserEntryPoint(entryMethod);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(221)
inline HRESULT ISymbolWriter::OpenMethod ( struct SymbolToken Method ) {
    HRESULT _hr = raw_OpenMethod(Method);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(222)
inline HRESULT ISymbolWriter::CloseMethod ( ) {
    HRESULT _hr = raw_CloseMethod();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(223)
inline HRESULT ISymbolWriter::DefineSequencePoints ( struct ISymbolDocumentWriter * document, SAFEARRAY * offsets, SAFEARRAY * lines, SAFEARRAY * columns, SAFEARRAY * endLines, SAFEARRAY * endColumns ) {
    HRESULT _hr = raw_DefineSequencePoints(document, offsets, lines, columns, endLines, endColumns);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(224)
inline long ISymbolWriter::OpenScope ( long StartOffset ) {
    long _result;
    HRESULT _hr = raw_OpenScope(StartOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(225)
inline HRESULT ISymbolWriter::CloseScope ( long EndOffset ) {
    HRESULT _hr = raw_CloseScope(EndOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(226)
inline HRESULT ISymbolWriter::SetScopeRange ( long scopeID, long StartOffset, long EndOffset ) {
    HRESULT _hr = raw_SetScopeRange(scopeID, StartOffset, EndOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(227)
inline HRESULT ISymbolWriter::DefineLocalVariable ( _bstr_t name, enum FieldAttributes Attributes, SAFEARRAY * signature, enum SymAddressKind addrKind, long addr1, long addr2, long addr3, long StartOffset, long EndOffset ) {
    HRESULT _hr = raw_DefineLocalVariable(name, Attributes, signature, addrKind, addr1, addr2, addr3, StartOffset, EndOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(228)
inline HRESULT ISymbolWriter::DefineParameter ( _bstr_t name, enum ParameterAttributes Attributes, long sequence, enum SymAddressKind addrKind, long addr1, long addr2, long addr3 ) {
    HRESULT _hr = raw_DefineParameter(name, Attributes, sequence, addrKind, addr1, addr2, addr3);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(229)
inline HRESULT ISymbolWriter::DefineField ( struct SymbolToken parent, _bstr_t name, enum FieldAttributes Attributes, SAFEARRAY * signature, enum SymAddressKind addrKind, long addr1, long addr2, long addr3 ) {
    HRESULT _hr = raw_DefineField(parent, name, Attributes, signature, addrKind, addr1, addr2, addr3);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(230)
inline HRESULT ISymbolWriter::DefineGlobalVariable ( _bstr_t name, enum FieldAttributes Attributes, SAFEARRAY * signature, enum SymAddressKind addrKind, long addr1, long addr2, long addr3 ) {
    HRESULT _hr = raw_DefineGlobalVariable(name, Attributes, signature, addrKind, addr1, addr2, addr3);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(231)
inline HRESULT ISymbolWriter::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(232)
inline HRESULT ISymbolWriter::SetSymAttribute ( struct SymbolToken parent, _bstr_t name, SAFEARRAY * data ) {
    HRESULT _hr = raw_SetSymAttribute(parent, name, data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(233)
inline HRESULT ISymbolWriter::OpenNamespace ( _bstr_t name ) {
    HRESULT _hr = raw_OpenNamespace(name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(234)
inline HRESULT ISymbolWriter::CloseNamespace ( ) {
    HRESULT _hr = raw_CloseNamespace();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(235)
inline HRESULT ISymbolWriter::UsingNamespace ( _bstr_t FullName ) {
    HRESULT _hr = raw_UsingNamespace(FullName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(236)
inline HRESULT ISymbolWriter::SetMethodSourceRange ( struct ISymbolDocumentWriter * startDoc, long startLine, long startColumn, struct ISymbolDocumentWriter * endDoc, long endLine, long endColumn ) {
    HRESULT _hr = raw_SetMethodSourceRange(startDoc, startLine, startColumn, endDoc, endLine, endColumn);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(237)
inline HRESULT ISymbolWriter::SetUnderlyingWriter ( long underlyingWriter ) {
    HRESULT _hr = raw_SetUnderlyingWriter(underlyingWriter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IFormatter wrapper method implementations
//

#pragma implementation_key(238)
inline _variant_t IFormatter::Deserialize ( struct _Stream * serializationStream ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Deserialize(serializationStream, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(239)
inline HRESULT IFormatter::Serialize ( struct _Stream * serializationStream, const _variant_t & graph ) {
    HRESULT _hr = raw_Serialize(serializationStream, graph);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(240)
inline ISurrogateSelectorPtr IFormatter::GetSurrogateSelector ( ) {
    struct ISurrogateSelector * _result;
    HRESULT _hr = get_SurrogateSelector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurrogateSelectorPtr(_result, false);
}

#pragma implementation_key(241)
inline void IFormatter::PutRefSurrogateSelector ( struct ISurrogateSelector * pRetVal ) {
    HRESULT _hr = putref_SurrogateSelector(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(242)
inline _SerializationBinderPtr IFormatter::GetBinder ( ) {
    struct _SerializationBinder * _result;
    HRESULT _hr = get_Binder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _SerializationBinderPtr(_result, false);
}

#pragma implementation_key(243)
inline void IFormatter::PutRefBinder ( struct _SerializationBinder * pRetVal ) {
    HRESULT _hr = putref_Binder(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(244)
inline struct StreamingContext IFormatter::GetContext ( ) {
    struct StreamingContext _result;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(245)
inline void IFormatter::PutContext ( struct StreamingContext pRetVal ) {
    HRESULT _hr = put_Context(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IFormatterConverter wrapper method implementations
//

#pragma implementation_key(246)
inline _variant_t IFormatterConverter::Convert ( const _variant_t & value, struct _Type * Type ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Convert(value, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(247)
inline _variant_t IFormatterConverter::Convert_2 ( const _variant_t & value, enum TypeCode TypeCode ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Convert_2(value, TypeCode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(248)
inline VARIANT_BOOL IFormatterConverter::ToBoolean ( const _variant_t & value ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_ToBoolean(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(249)
inline unsigned short IFormatterConverter::ToChar ( const _variant_t & value ) {
    unsigned short _result;
    HRESULT _hr = raw_ToChar(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(250)
inline char IFormatterConverter::ToSByte ( const _variant_t & value ) {
    char _result;
    HRESULT _hr = raw_ToSByte(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(251)
inline unsigned char IFormatterConverter::ToByte ( const _variant_t & value ) {
    unsigned char _result;
    HRESULT _hr = raw_ToByte(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(252)
inline short IFormatterConverter::ToInt16 ( const _variant_t & value ) {
    short _result;
    HRESULT _hr = raw_ToInt16(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(253)
inline unsigned short IFormatterConverter::ToUInt16 ( const _variant_t & value ) {
    unsigned short _result;
    HRESULT _hr = raw_ToUInt16(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(254)
inline long IFormatterConverter::ToInt32 ( const _variant_t & value ) {
    long _result;
    HRESULT _hr = raw_ToInt32(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(255)
inline unsigned long IFormatterConverter::ToUInt32 ( const _variant_t & value ) {
    unsigned long _result;
    HRESULT _hr = raw_ToUInt32(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(256)
inline __int64 IFormatterConverter::ToInt64 ( const _variant_t & value ) {
    __int64 _result;
    HRESULT _hr = raw_ToInt64(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(257)
inline unsigned __int64 IFormatterConverter::ToUInt64 ( const _variant_t & value ) {
    unsigned __int64 _result;
    HRESULT _hr = raw_ToUInt64(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(258)
inline float IFormatterConverter::ToSingle ( const _variant_t & value ) {
    float _result;
    HRESULT _hr = raw_ToSingle(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(259)
inline double IFormatterConverter::ToDouble ( const _variant_t & value ) {
    double _result;
    HRESULT _hr = raw_ToDouble(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(260)
inline DECIMAL IFormatterConverter::ToDecimal ( const _variant_t & value ) {
    DECIMAL _result;
    HRESULT _hr = raw_ToDecimal(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(261)
inline DATE IFormatterConverter::ToDateTime ( const _variant_t & value ) {
    DATE _result;
    HRESULT _hr = raw_ToDateTime(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(262)
inline _bstr_t IFormatterConverter::GetToString ( const _variant_t & value ) {
    BSTR _result;
    HRESULT _hr = get_ToString(value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ISerializationSurrogate wrapper method implementations
//

#pragma implementation_key(263)
inline HRESULT ISerializationSurrogate::GetObjectData ( const _variant_t & obj, struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(obj, info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(264)
inline _variant_t ISerializationSurrogate::SetObjectData ( const _variant_t & obj, struct _SerializationInfo * info, struct StreamingContext Context, struct ISurrogateSelector * selector ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_SetObjectData(obj, info, Context, selector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ISurrogateSelector wrapper method implementations
//

#pragma implementation_key(265)
inline HRESULT ISurrogateSelector::ChainSelector ( struct ISurrogateSelector * selector ) {
    HRESULT _hr = raw_ChainSelector(selector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(266)
inline ISerializationSurrogatePtr ISurrogateSelector::GetSurrogate ( struct _Type * Type, struct StreamingContext Context, struct ISurrogateSelector * * selector ) {
    struct ISerializationSurrogate * _result;
    HRESULT _hr = raw_GetSurrogate(Type, Context, selector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISerializationSurrogatePtr(_result, false);
}

#pragma implementation_key(267)
inline ISurrogateSelectorPtr ISurrogateSelector::GetNextSelector ( ) {
    struct ISurrogateSelector * _result;
    HRESULT _hr = raw_GetNextSelector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurrogateSelectorPtr(_result, false);
}

//
// interface IResourceReader wrapper method implementations
//

#pragma implementation_key(268)
inline HRESULT IResourceReader::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(269)
inline IDictionaryEnumeratorPtr IResourceReader::GetEnumerator ( ) {
    struct IDictionaryEnumerator * _result;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryEnumeratorPtr(_result, false);
}

//
// interface IResourceWriter wrapper method implementations
//

#pragma implementation_key(270)
inline HRESULT IResourceWriter::AddResource ( _bstr_t name, _bstr_t value ) {
    HRESULT _hr = raw_AddResource(name, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(271)
inline HRESULT IResourceWriter::AddResource_2 ( _bstr_t name, const _variant_t & value ) {
    HRESULT _hr = raw_AddResource_2(name, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(272)
inline HRESULT IResourceWriter::AddResource_3 ( _bstr_t name, SAFEARRAY * value ) {
    HRESULT _hr = raw_AddResource_3(name, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(273)
inline HRESULT IResourceWriter::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(274)
inline HRESULT IResourceWriter::Generate ( ) {
    HRESULT _hr = raw_Generate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICryptoTransform wrapper method implementations
//

#pragma implementation_key(275)
inline long ICryptoTransform::GetInputBlockSize ( ) {
    long _result;
    HRESULT _hr = get_InputBlockSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(276)
inline long ICryptoTransform::GetOutputBlockSize ( ) {
    long _result;
    HRESULT _hr = get_OutputBlockSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(277)
inline VARIANT_BOOL ICryptoTransform::GetCanTransformMultipleBlocks ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_CanTransformMultipleBlocks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(278)
inline VARIANT_BOOL ICryptoTransform::GetCanReuseTransform ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_CanReuseTransform(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(279)
inline long ICryptoTransform::TransformBlock ( SAFEARRAY * inputBuffer, long inputOffset, long inputCount, SAFEARRAY * outputBuffer, long outputOffset ) {
    long _result;
    HRESULT _hr = raw_TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(280)
inline SAFEARRAY * ICryptoTransform::TransformFinalBlock ( SAFEARRAY * inputBuffer, long inputOffset, long inputCount ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_TransformFinalBlock(inputBuffer, inputOffset, inputCount, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISecurityEncodable wrapper method implementations
//

#pragma implementation_key(281)
inline _SecurityElementPtr ISecurityEncodable::ToXml ( ) {
    struct _SecurityElement * _result;
    HRESULT _hr = raw_ToXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _SecurityElementPtr(_result, false);
}

#pragma implementation_key(282)
inline HRESULT ISecurityEncodable::FromXml ( struct _SecurityElement * e ) {
    HRESULT _hr = raw_FromXml(e);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISecurityPolicyEncodable wrapper method implementations
//

#pragma implementation_key(283)
inline _SecurityElementPtr ISecurityPolicyEncodable::ToXml ( struct _PolicyLevel * level ) {
    struct _SecurityElement * _result;
    HRESULT _hr = raw_ToXml(level, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _SecurityElementPtr(_result, false);
}

#pragma implementation_key(284)
inline HRESULT ISecurityPolicyEncodable::FromXml ( struct _SecurityElement * e, struct _PolicyLevel * level ) {
    HRESULT _hr = raw_FromXml(e, level);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMembershipCondition wrapper method implementations
//

#pragma implementation_key(285)
inline VARIANT_BOOL IMembershipCondition::Check ( struct _Evidence * Evidence ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Check(Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(286)
inline IMembershipConditionPtr IMembershipCondition::Copy ( ) {
    struct IMembershipCondition * _result;
    HRESULT _hr = raw_Copy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMembershipConditionPtr(_result, false);
}

#pragma implementation_key(287)
inline _bstr_t IMembershipCondition::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(288)
inline VARIANT_BOOL IMembershipCondition::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IIdentityPermissionFactory wrapper method implementations
//

#pragma implementation_key(289)
inline IPermissionPtr IIdentityPermissionFactory::CreateIdentityPermission ( struct _Evidence * Evidence ) {
    struct IPermission * _result;
    HRESULT _hr = raw_CreateIdentityPermission(Evidence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

//
// interface IIdentity wrapper method implementations
//

#pragma implementation_key(290)
inline _bstr_t IIdentity::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(291)
inline _bstr_t IIdentity::GetAuthenticationType ( ) {
    BSTR _result;
    HRESULT _hr = get_AuthenticationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(292)
inline VARIANT_BOOL IIdentity::GetIsAuthenticated ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAuthenticated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPrincipal wrapper method implementations
//

#pragma implementation_key(293)
inline IIdentityPtr IPrincipal::GetIdentity ( ) {
    struct IIdentity * _result;
    HRESULT _hr = get_Identity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IIdentityPtr(_result, false);
}

#pragma implementation_key(294)
inline VARIANT_BOOL IPrincipal::IsInRole ( _bstr_t role ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsInRole(role, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICustomAdapter wrapper method implementations
//

#pragma implementation_key(295)
inline IUnknownPtr ICustomAdapter::GetUnderlyingObject ( ) {
    IUnknown * _result;
    HRESULT _hr = raw_GetUnderlyingObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface ICustomMarshaler wrapper method implementations
//

#pragma implementation_key(296)
inline _variant_t ICustomMarshaler::MarshalNativeToManaged ( long pNativeData ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_MarshalNativeToManaged(pNativeData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(297)
inline long ICustomMarshaler::MarshalManagedToNative ( const _variant_t & ManagedObj ) {
    long _result;
    HRESULT _hr = raw_MarshalManagedToNative(ManagedObj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(298)
inline HRESULT ICustomMarshaler::CleanUpNativeData ( long pNativeData ) {
    HRESULT _hr = raw_CleanUpNativeData(pNativeData);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(299)
inline HRESULT ICustomMarshaler::CleanUpManagedData ( const _variant_t & ManagedObj ) {
    HRESULT _hr = raw_CleanUpManagedData(ManagedObj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(300)
inline long ICustomMarshaler::GetNativeDataSize ( ) {
    long _result;
    HRESULT _hr = raw_GetNativeDataSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICustomFactory wrapper method implementations
//

#pragma implementation_key(301)
inline _MarshalByRefObjectPtr ICustomFactory::CreateInstance ( struct _Type * serverType ) {
    struct _MarshalByRefObject * _result;
    HRESULT _hr = raw_CreateInstance(serverType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MarshalByRefObjectPtr(_result, false);
}

//
// interface IRegistrationServices wrapper method implementations
//

#pragma implementation_key(302)
inline VARIANT_BOOL IRegistrationServices::RegisterAssembly ( struct _Assembly * Assembly, enum AssemblyRegistrationFlags flags ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_RegisterAssembly(Assembly, flags, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(303)
inline VARIANT_BOOL IRegistrationServices::UnregisterAssembly ( struct _Assembly * Assembly ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_UnregisterAssembly(Assembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(304)
inline SAFEARRAY * IRegistrationServices::GetRegistrableTypesInAssembly ( struct _Assembly * Assembly ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetRegistrableTypesInAssembly(Assembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(305)
inline _bstr_t IRegistrationServices::GetProgIdForType ( struct _Type * Type ) {
    BSTR _result;
    HRESULT _hr = raw_GetProgIdForType(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(306)
inline HRESULT IRegistrationServices::RegisterTypeForComClients ( struct _Type * Type, GUID * G ) {
    HRESULT _hr = raw_RegisterTypeForComClients(Type, G);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(307)
inline GUID IRegistrationServices::GetManagedCategoryGuid ( ) {
    GUID _result;
    HRESULT _hr = raw_GetManagedCategoryGuid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(308)
inline VARIANT_BOOL IRegistrationServices::TypeRequiresRegistration ( struct _Type * Type ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_TypeRequiresRegistration(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(309)
inline VARIANT_BOOL IRegistrationServices::TypeRepresentsComType ( struct _Type * Type ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_TypeRepresentsComType(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITypeLibImporterNotifySink wrapper method implementations
//

#pragma implementation_key(310)
inline HRESULT ITypeLibImporterNotifySink::ReportEvent ( enum ImporterEventKind eventKind, long eventCode, _bstr_t eventMsg ) {
    HRESULT _hr = raw_ReportEvent(eventKind, eventCode, eventMsg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(311)
inline _AssemblyPtr ITypeLibImporterNotifySink::ResolveRef ( IUnknown * typeLib ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_ResolveRef(typeLib, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

//
// interface ITypeLibExporterNotifySink wrapper method implementations
//

#pragma implementation_key(312)
inline HRESULT ITypeLibExporterNotifySink::ReportEvent ( enum ExporterEventKind eventKind, long eventCode, _bstr_t eventMsg ) {
    HRESULT _hr = raw_ReportEvent(eventKind, eventCode, eventMsg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(313)
inline IUnknownPtr ITypeLibExporterNotifySink::ResolveRef ( struct _Assembly * Assembly ) {
    IUnknown * _result;
    HRESULT _hr = raw_ResolveRef(Assembly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface ITypeLibConverter wrapper method implementations
//

#pragma implementation_key(314)
inline _AssemblyBuilderPtr ITypeLibConverter::ConvertTypeLibToAssembly ( IUnknown * typeLib, _bstr_t asmFileName, enum TypeLibImporterFlags flags, struct ITypeLibImporterNotifySink * notifySink, SAFEARRAY * publicKey, struct _StrongNameKeyPair * keyPair, _bstr_t asmNamespace, struct _Version * asmVersion ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_ConvertTypeLibToAssembly(typeLib, asmFileName, flags, notifySink, publicKey, keyPair, asmNamespace, asmVersion, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

#pragma implementation_key(315)
inline IUnknownPtr ITypeLibConverter::ConvertAssemblyToTypeLib ( struct _Assembly * Assembly, _bstr_t typeLibName, enum TypeLibExporterFlags flags, struct ITypeLibExporterNotifySink * notifySink ) {
    IUnknown * _result;
    HRESULT _hr = raw_ConvertAssemblyToTypeLib(Assembly, typeLibName, flags, notifySink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(316)
inline VARIANT_BOOL ITypeLibConverter::GetPrimaryInteropAssembly ( GUID G, long major, long minor, long lcid, BSTR * asmName, BSTR * asmCodeBase ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_GetPrimaryInteropAssembly(G, major, minor, lcid, asmName, asmCodeBase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(317)
inline _AssemblyBuilderPtr ITypeLibConverter::ConvertTypeLibToAssembly_2 ( IUnknown * typeLib, _bstr_t asmFileName, long flags, struct ITypeLibImporterNotifySink * notifySink, SAFEARRAY * publicKey, struct _StrongNameKeyPair * keyPair, VARIANT_BOOL unsafeInterfaces ) {
    struct _AssemblyBuilder * _result;
    HRESULT _hr = raw_ConvertTypeLibToAssembly_2(typeLib, asmFileName, flags, notifySink, publicKey, keyPair, unsafeInterfaces, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyBuilderPtr(_result, false);
}

//
// interface ITypeLibExporterNameProvider wrapper method implementations
//

#pragma implementation_key(318)
inline SAFEARRAY * ITypeLibExporterNameProvider::GetNames ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IExpando wrapper method implementations
//

#pragma implementation_key(319)
inline _FieldInfoPtr IExpando::AddField ( _bstr_t name ) {
    struct _FieldInfo * _result;
    HRESULT _hr = raw_AddField(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

#pragma implementation_key(320)
inline _PropertyInfoPtr IExpando::AddProperty ( _bstr_t name ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_AddProperty(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(321)
inline _MethodInfoPtr IExpando::AddMethod ( _bstr_t name, struct _Delegate * Method ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_AddMethod(name, Method, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(322)
inline HRESULT IExpando::RemoveMember ( struct _MemberInfo * m ) {
    HRESULT _hr = raw_RemoveMember(m);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IStackWalk wrapper method implementations
//

#pragma implementation_key(323)
inline HRESULT IStackWalk::Assert ( ) {
    HRESULT _hr = raw_Assert();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(324)
inline HRESULT IStackWalk::Demand ( ) {
    HRESULT _hr = raw_Demand();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(325)
inline HRESULT IStackWalk::Deny ( ) {
    HRESULT _hr = raw_Deny();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(326)
inline HRESULT IStackWalk::PermitOnly ( ) {
    HRESULT _hr = raw_PermitOnly();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IPermission wrapper method implementations
//

#pragma implementation_key(327)
inline IPermissionPtr IPermission::Copy ( ) {
    struct IPermission * _result;
    HRESULT _hr = raw_Copy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

#pragma implementation_key(328)
inline IPermissionPtr IPermission::Intersect ( struct IPermission * Target ) {
    struct IPermission * _result;
    HRESULT _hr = raw_Intersect(Target, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

#pragma implementation_key(329)
inline IPermissionPtr IPermission::Union ( struct IPermission * Target ) {
    struct IPermission * _result;
    HRESULT _hr = raw_Union(Target, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPermissionPtr(_result, false);
}

#pragma implementation_key(330)
inline VARIANT_BOOL IPermission::IsSubsetOf ( struct IPermission * Target ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsSubsetOf(Target, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(331)
inline HRESULT IPermission::Demand ( ) {
    HRESULT _hr = raw_Demand();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IUnrestrictedPermission wrapper method implementations
//

#pragma implementation_key(332)
inline VARIANT_BOOL IUnrestrictedPermission::IsUnrestricted ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsUnrestricted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IContextAttribute wrapper method implementations
//

#pragma implementation_key(333)
inline VARIANT_BOOL IContextAttribute::IsContextOK ( struct _Context * ctx, struct IConstructionCallMessage * msg ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsContextOK(ctx, msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(334)
inline HRESULT IContextAttribute::GetPropertiesForNewContext ( struct IConstructionCallMessage * msg ) {
    HRESULT _hr = raw_GetPropertiesForNewContext(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IContextProperty wrapper method implementations
//

#pragma implementation_key(335)
inline _bstr_t IContextProperty::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(336)
inline VARIANT_BOOL IContextProperty::IsNewContextOK ( struct _Context * newCtx ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsNewContextOK(newCtx, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(337)
inline HRESULT IContextProperty::Freeze ( struct _Context * newContext ) {
    HRESULT _hr = raw_Freeze(newContext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IActivator wrapper method implementations
//

#pragma implementation_key(338)
inline IActivatorPtr IActivator::GetNextActivator ( ) {
    struct IActivator * _result;
    HRESULT _hr = get_NextActivator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IActivatorPtr(_result, false);
}

#pragma implementation_key(339)
inline void IActivator::PutRefNextActivator ( struct IActivator * pRetVal ) {
    HRESULT _hr = putref_NextActivator(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(340)
inline IConstructionReturnMessagePtr IActivator::Activate ( struct IConstructionCallMessage * msg ) {
    struct IConstructionReturnMessage * _result;
    HRESULT _hr = raw_Activate(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IConstructionReturnMessagePtr(_result, false);
}

#pragma implementation_key(341)
inline enum ActivatorLevel IActivator::Getlevel ( ) {
    enum ActivatorLevel _result;
    HRESULT _hr = get_level(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IMessageSink wrapper method implementations
//

#pragma implementation_key(342)
inline IMessagePtr IMessageSink::SyncProcessMessage ( struct IMessage * msg ) {
    struct IMessage * _result;
    HRESULT _hr = raw_SyncProcessMessage(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessagePtr(_result, false);
}

#pragma implementation_key(343)
inline IMessageCtrlPtr IMessageSink::AsyncProcessMessage ( struct IMessage * msg, struct IMessageSink * replySink ) {
    struct IMessageCtrl * _result;
    HRESULT _hr = raw_AsyncProcessMessage(msg, replySink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageCtrlPtr(_result, false);
}

#pragma implementation_key(344)
inline IMessageSinkPtr IMessageSink::GetNextSink ( ) {
    struct IMessageSink * _result;
    HRESULT _hr = get_NextSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IClientResponseChannelSinkStack wrapper method implementations
//

#pragma implementation_key(345)
inline HRESULT IClientResponseChannelSinkStack::AsyncProcessResponse ( struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(346)
inline HRESULT IClientResponseChannelSinkStack::DispatchReplyMessage ( struct IMessage * msg ) {
    HRESULT _hr = raw_DispatchReplyMessage(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(347)
inline HRESULT IClientResponseChannelSinkStack::DispatchException ( struct _Exception * e ) {
    HRESULT _hr = raw_DispatchException(e);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IClientChannelSinkStack wrapper method implementations
//

#pragma implementation_key(348)
inline HRESULT IClientChannelSinkStack::Push ( struct IClientChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_Push(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(349)
inline _variant_t IClientChannelSinkStack::Pop ( struct IClientChannelSink * sink ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Pop(sink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IServerResponseChannelSinkStack wrapper method implementations
//

#pragma implementation_key(350)
inline HRESULT IServerResponseChannelSinkStack::AsyncProcessResponse ( struct IMessage * msg, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(msg, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(351)
inline _StreamPtr IServerResponseChannelSinkStack::GetResponseStream ( struct IMessage * msg, struct ITransportHeaders * headers ) {
    struct _Stream * _result;
    HRESULT _hr = raw_GetResponseStream(msg, headers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

//
// interface IServerChannelSinkStack wrapper method implementations
//

#pragma implementation_key(352)
inline HRESULT IServerChannelSinkStack::Push ( struct IServerChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_Push(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(353)
inline _variant_t IServerChannelSinkStack::Pop ( struct IServerChannelSink * sink ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Pop(sink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(354)
inline HRESULT IServerChannelSinkStack::Store ( struct IServerChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_Store(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(355)
inline HRESULT IServerChannelSinkStack::StoreAndDispatch ( struct IServerChannelSink * sink, const _variant_t & state ) {
    HRESULT _hr = raw_StoreAndDispatch(sink, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(356)
inline HRESULT IServerChannelSinkStack::ServerCallback ( struct IAsyncResult * ar ) {
    HRESULT _hr = raw_ServerCallback(ar);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IMessage wrapper method implementations
//

#pragma implementation_key(357)
inline IDictionaryPtr IMessage::GetProperties ( ) {
    struct IDictionary * _result;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryPtr(_result, false);
}

//
// interface IMethodMessage wrapper method implementations
//

#pragma implementation_key(358)
inline _bstr_t IMethodMessage::GetUri ( ) {
    BSTR _result;
    HRESULT _hr = get_Uri(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(359)
inline _bstr_t IMethodMessage::GetMethodName ( ) {
    BSTR _result;
    HRESULT _hr = get_MethodName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(360)
inline _bstr_t IMethodMessage::GettypeName ( ) {
    BSTR _result;
    HRESULT _hr = get_typeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(361)
inline _variant_t IMethodMessage::GetMethodSignature ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_MethodSignature(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(362)
inline long IMethodMessage::GetArgCount ( ) {
    long _result;
    HRESULT _hr = get_ArgCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(363)
inline _bstr_t IMethodMessage::GetArgName ( long index ) {
    BSTR _result;
    HRESULT _hr = raw_GetArgName(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(364)
inline _variant_t IMethodMessage::GetArg ( long argNum ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetArg(argNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(365)
inline SAFEARRAY * IMethodMessage::Getargs ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_args(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(366)
inline VARIANT_BOOL IMethodMessage::GetHasVarArgs ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_HasVarArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(367)
inline _LogicalCallContextPtr IMethodMessage::GetLogicalCallContext ( ) {
    struct _LogicalCallContext * _result;
    HRESULT _hr = get_LogicalCallContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _LogicalCallContextPtr(_result, false);
}

#pragma implementation_key(368)
inline _MethodBasePtr IMethodMessage::GetMethodBase ( ) {
    struct _MethodBase * _result;
    HRESULT _hr = get_MethodBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

//
// interface IMethodCallMessage wrapper method implementations
//

#pragma implementation_key(369)
inline long IMethodCallMessage::GetInArgCount ( ) {
    long _result;
    HRESULT _hr = get_InArgCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(370)
inline _bstr_t IMethodCallMessage::GetInArgName ( long index ) {
    BSTR _result;
    HRESULT _hr = raw_GetInArgName(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(371)
inline _variant_t IMethodCallMessage::GetInArg ( long argNum ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetInArg(argNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(372)
inline SAFEARRAY * IMethodCallMessage::GetInArgs ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_InArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISponsor wrapper method implementations
//

#pragma implementation_key(373)
inline struct TimeSpan ISponsor::Renewal ( struct ILease * lease ) {
    struct TimeSpan _result;
    HRESULT _hr = raw_Renewal(lease, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IContextPropertyActivator wrapper method implementations
//

#pragma implementation_key(374)
inline VARIANT_BOOL IContextPropertyActivator::IsOKToActivate ( struct IConstructionCallMessage * msg ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsOKToActivate(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(375)
inline HRESULT IContextPropertyActivator::CollectFromClientContext ( struct IConstructionCallMessage * msg ) {
    HRESULT _hr = raw_CollectFromClientContext(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(376)
inline VARIANT_BOOL IContextPropertyActivator::DeliverClientContextToServerContext ( struct IConstructionCallMessage * msg ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_DeliverClientContextToServerContext(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(377)
inline HRESULT IContextPropertyActivator::CollectFromServerContext ( struct IConstructionReturnMessage * msg ) {
    HRESULT _hr = raw_CollectFromServerContext(msg);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(378)
inline VARIANT_BOOL IContextPropertyActivator::DeliverServerContextToClientContext ( struct IConstructionReturnMessage * msg ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_DeliverServerContextToClientContext(msg, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IChannel wrapper method implementations
//

#pragma implementation_key(379)
inline long IChannel::GetChannelPriority ( ) {
    long _result;
    HRESULT _hr = get_ChannelPriority(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(380)
inline _bstr_t IChannel::GetChannelName ( ) {
    BSTR _result;
    HRESULT _hr = get_ChannelName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(381)
inline _bstr_t IChannel::Parse ( _bstr_t Url, BSTR * objectURI ) {
    BSTR _result;
    HRESULT _hr = raw_Parse(Url, objectURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IChannelSender wrapper method implementations
//

#pragma implementation_key(382)
inline IMessageSinkPtr IChannelSender::CreateMessageSink ( _bstr_t Url, const _variant_t & remoteChannelData, BSTR * objectURI ) {
    struct IMessageSink * _result;
    HRESULT _hr = raw_CreateMessageSink(Url, remoteChannelData, objectURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IChannelReceiver wrapper method implementations
//

#pragma implementation_key(383)
inline _variant_t IChannelReceiver::GetChannelData ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ChannelData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(384)
inline SAFEARRAY * IChannelReceiver::GetUrlsForUri ( _bstr_t objectURI ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetUrlsForUri(objectURI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(385)
inline HRESULT IChannelReceiver::StartListening ( const _variant_t & data ) {
    HRESULT _hr = raw_StartListening(data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(386)
inline HRESULT IChannelReceiver::StopListening ( const _variant_t & data ) {
    HRESULT _hr = raw_StopListening(data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IServerChannelSinkProvider wrapper method implementations
//

#pragma implementation_key(387)
inline HRESULT IServerChannelSinkProvider::GetChannelData ( struct IChannelDataStore * ChannelData ) {
    HRESULT _hr = raw_GetChannelData(ChannelData);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(388)
inline IServerChannelSinkPtr IServerChannelSinkProvider::CreateSink ( struct IChannelReceiver * channel ) {
    struct IServerChannelSink * _result;
    HRESULT _hr = raw_CreateSink(channel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkPtr(_result, false);
}

#pragma implementation_key(389)
inline IServerChannelSinkProviderPtr IServerChannelSinkProvider::GetNext ( ) {
    struct IServerChannelSinkProvider * _result;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkProviderPtr(_result, false);
}

#pragma implementation_key(390)
inline void IServerChannelSinkProvider::PutRefNext ( struct IServerChannelSinkProvider * pRetVal ) {
    HRESULT _hr = putref_Next(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IChannelSinkBase wrapper method implementations
//

#pragma implementation_key(391)
inline IDictionaryPtr IChannelSinkBase::GetProperties ( ) {
    struct IDictionary * _result;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDictionaryPtr(_result, false);
}

//
// interface IServerChannelSink wrapper method implementations
//

#pragma implementation_key(392)
inline enum ServerProcessing IServerChannelSink::ProcessMessage ( struct IServerChannelSinkStack * sinkStack, struct IMessage * requestMsg, struct ITransportHeaders * requestHeaders, struct _Stream * requestStream, struct IMessage * * responseMsg, struct ITransportHeaders * * responseHeaders, struct _Stream * * responseStream ) {
    enum ServerProcessing _result;
    HRESULT _hr = raw_ProcessMessage(sinkStack, requestMsg, requestHeaders, requestStream, responseMsg, responseHeaders, responseStream, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(393)
inline HRESULT IServerChannelSink::AsyncProcessResponse ( struct IServerResponseChannelSinkStack * sinkStack, const _variant_t & state, struct IMessage * msg, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(sinkStack, state, msg, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(394)
inline _StreamPtr IServerChannelSink::GetResponseStream ( struct IServerResponseChannelSinkStack * sinkStack, const _variant_t & state, struct IMessage * msg, struct ITransportHeaders * headers ) {
    struct _Stream * _result;
    HRESULT _hr = raw_GetResponseStream(sinkStack, state, msg, headers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

#pragma implementation_key(395)
inline IServerChannelSinkPtr IServerChannelSink::GetNextChannelSink ( ) {
    struct IServerChannelSink * _result;
    HRESULT _hr = get_NextChannelSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkPtr(_result, false);
}

//
// interface IConstructionCallMessage wrapper method implementations
//

#pragma implementation_key(396)
inline IActivatorPtr IConstructionCallMessage::GetActivator ( ) {
    struct IActivator * _result;
    HRESULT _hr = get_Activator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IActivatorPtr(_result, false);
}

#pragma implementation_key(397)
inline void IConstructionCallMessage::PutRefActivator ( struct IActivator * pRetVal ) {
    HRESULT _hr = putref_Activator(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(398)
inline SAFEARRAY * IConstructionCallMessage::GetCallSiteActivationAttributes ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_CallSiteActivationAttributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(399)
inline _bstr_t IConstructionCallMessage::GetActivationTypeName ( ) {
    BSTR _result;
    HRESULT _hr = get_ActivationTypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(400)
inline _TypePtr IConstructionCallMessage::GetActivationType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ActivationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(401)
inline IListPtr IConstructionCallMessage::GetContextProperties ( ) {
    struct IList * _result;
    HRESULT _hr = get_ContextProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IListPtr(_result, false);
}

//
// interface IMethodReturnMessage wrapper method implementations
//

#pragma implementation_key(402)
inline long IMethodReturnMessage::GetOutArgCount ( ) {
    long _result;
    HRESULT _hr = get_OutArgCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(403)
inline _bstr_t IMethodReturnMessage::GetOutArgName ( long index ) {
    BSTR _result;
    HRESULT _hr = raw_GetOutArgName(index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(404)
inline _variant_t IMethodReturnMessage::GetOutArg ( long argNum ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetOutArg(argNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(405)
inline SAFEARRAY * IMethodReturnMessage::GetOutArgs ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_OutArgs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(406)
inline _ExceptionPtr IMethodReturnMessage::GetException ( ) {
    struct _Exception * _result;
    HRESULT _hr = get_Exception(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ExceptionPtr(_result, false);
}

#pragma implementation_key(407)
inline _variant_t IMethodReturnMessage::GetReturnValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ReturnValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IChannelReceiverHook wrapper method implementations
//

#pragma implementation_key(408)
inline _bstr_t IChannelReceiverHook::GetChannelScheme ( ) {
    BSTR _result;
    HRESULT _hr = get_ChannelScheme(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(409)
inline VARIANT_BOOL IChannelReceiverHook::GetWantsToListen ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_WantsToListen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(410)
inline IServerChannelSinkPtr IChannelReceiverHook::GetChannelSinkChain ( ) {
    struct IServerChannelSink * _result;
    HRESULT _hr = get_ChannelSinkChain(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IServerChannelSinkPtr(_result, false);
}

#pragma implementation_key(411)
inline HRESULT IChannelReceiverHook::AddHookChannelUri ( _bstr_t channelUri ) {
    HRESULT _hr = raw_AddHookChannelUri(channelUri);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IClientChannelSinkProvider wrapper method implementations
//

#pragma implementation_key(412)
inline IClientChannelSinkPtr IClientChannelSinkProvider::CreateSink ( struct IChannelSender * channel, _bstr_t Url, const _variant_t & remoteChannelData ) {
    struct IClientChannelSink * _result;
    HRESULT _hr = raw_CreateSink(channel, Url, remoteChannelData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IClientChannelSinkPtr(_result, false);
}

#pragma implementation_key(413)
inline IClientChannelSinkProviderPtr IClientChannelSinkProvider::GetNext ( ) {
    struct IClientChannelSinkProvider * _result;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IClientChannelSinkProviderPtr(_result, false);
}

#pragma implementation_key(414)
inline void IClientChannelSinkProvider::PutRefNext ( struct IClientChannelSinkProvider * pRetVal ) {
    HRESULT _hr = putref_Next(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IClientChannelSink wrapper method implementations
//

#pragma implementation_key(415)
inline HRESULT IClientChannelSink::ProcessMessage ( struct IMessage * msg, struct ITransportHeaders * requestHeaders, struct _Stream * requestStream, struct ITransportHeaders * * responseHeaders, struct _Stream * * responseStream ) {
    HRESULT _hr = raw_ProcessMessage(msg, requestHeaders, requestStream, responseHeaders, responseStream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(416)
inline HRESULT IClientChannelSink::AsyncProcessRequest ( struct IClientChannelSinkStack * sinkStack, struct IMessage * msg, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessRequest(sinkStack, msg, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(417)
inline HRESULT IClientChannelSink::AsyncProcessResponse ( struct IClientResponseChannelSinkStack * sinkStack, const _variant_t & state, struct ITransportHeaders * headers, struct _Stream * Stream ) {
    HRESULT _hr = raw_AsyncProcessResponse(sinkStack, state, headers, Stream);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(418)
inline _StreamPtr IClientChannelSink::GetRequestStream ( struct IMessage * msg, struct ITransportHeaders * headers ) {
    struct _Stream * _result;
    HRESULT _hr = raw_GetRequestStream(msg, headers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

#pragma implementation_key(419)
inline IClientChannelSinkPtr IClientChannelSink::GetNextChannelSink ( ) {
    struct IClientChannelSink * _result;
    HRESULT _hr = get_NextChannelSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IClientChannelSinkPtr(_result, false);
}

//
// interface IChannelDataStore wrapper method implementations
//

#pragma implementation_key(420)
inline SAFEARRAY * IChannelDataStore::GetChannelUris ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_ChannelUris(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(421)
inline _variant_t IChannelDataStore::GetItem ( const _variant_t & key ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(422)
inline void IChannelDataStore::PutRefItem ( const _variant_t & key, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(key, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITransportHeaders wrapper method implementations
//

#pragma implementation_key(423)
inline _variant_t ITransportHeaders::GetItem ( const _variant_t & key ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(424)
inline void ITransportHeaders::PutRefItem ( const _variant_t & key, const _variant_t & pRetVal ) {
    HRESULT _hr = putref_Item(key, pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(425)
inline IEnumVARIANTPtr ITransportHeaders::GetEnumerator ( ) {
    struct IEnumVARIANT * _result;
    HRESULT _hr = raw_GetEnumerator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEnumVARIANTPtr(_result, false);
}

//
// interface IContributeClientContextSink wrapper method implementations
//

#pragma implementation_key(426)
inline IMessageSinkPtr IContributeClientContextSink::GetClientContextSink ( struct IMessageSink * NextSink ) {
    struct IMessageSink * _result;
    HRESULT _hr = raw_GetClientContextSink(NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IContributeDynamicSink wrapper method implementations
//

#pragma implementation_key(427)
inline IDynamicMessageSinkPtr IContributeDynamicSink::GetDynamicSink ( ) {
    struct IDynamicMessageSink * _result;
    HRESULT _hr = raw_GetDynamicSink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDynamicMessageSinkPtr(_result, false);
}

//
// interface IContributeEnvoySink wrapper method implementations
//

#pragma implementation_key(428)
inline IMessageSinkPtr IContributeEnvoySink::GetEnvoySink ( struct _MarshalByRefObject * obj, struct IMessageSink * NextSink ) {
    struct IMessageSink * _result;
    HRESULT _hr = raw_GetEnvoySink(obj, NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IContributeObjectSink wrapper method implementations
//

#pragma implementation_key(429)
inline IMessageSinkPtr IContributeObjectSink::GetObjectSink ( struct _MarshalByRefObject * obj, struct IMessageSink * NextSink ) {
    struct IMessageSink * _result;
    HRESULT _hr = raw_GetObjectSink(obj, NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IContributeServerContextSink wrapper method implementations
//

#pragma implementation_key(430)
inline IMessageSinkPtr IContributeServerContextSink::GetServerContextSink ( struct IMessageSink * NextSink ) {
    struct IMessageSink * _result;
    HRESULT _hr = raw_GetServerContextSink(NextSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

//
// interface IDynamicProperty wrapper method implementations
//

#pragma implementation_key(431)
inline _bstr_t IDynamicProperty::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IDynamicMessageSink wrapper method implementations
//

#pragma implementation_key(432)
inline HRESULT IDynamicMessageSink::ProcessMessageStart ( struct IMessage * reqMsg, VARIANT_BOOL bCliSide, VARIANT_BOOL bAsync ) {
    HRESULT _hr = raw_ProcessMessageStart(reqMsg, bCliSide, bAsync);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(433)
inline HRESULT IDynamicMessageSink::ProcessMessageFinish ( struct IMessage * replyMsg, VARIANT_BOOL bCliSide, VARIANT_BOOL bAsync ) {
    HRESULT _hr = raw_ProcessMessageFinish(replyMsg, bCliSide, bAsync);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ILease wrapper method implementations
//

#pragma implementation_key(434)
inline HRESULT ILease::Register ( struct ISponsor * obj, struct TimeSpan renewalTime ) {
    HRESULT _hr = raw_Register(obj, renewalTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(435)
inline HRESULT ILease::Register_2 ( struct ISponsor * obj ) {
    HRESULT _hr = raw_Register_2(obj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(436)
inline HRESULT ILease::Unregister ( struct ISponsor * obj ) {
    HRESULT _hr = raw_Unregister(obj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(437)
inline struct TimeSpan ILease::Renew ( struct TimeSpan renewalTime ) {
    struct TimeSpan _result;
    HRESULT _hr = raw_Renew(renewalTime, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(438)
inline struct TimeSpan ILease::GetRenewOnCallTime ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_RenewOnCallTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(439)
inline void ILease::PutRenewOnCallTime ( struct TimeSpan pRetVal ) {
    HRESULT _hr = put_RenewOnCallTime(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(440)
inline struct TimeSpan ILease::GetSponsorshipTimeout ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_SponsorshipTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(441)
inline void ILease::PutSponsorshipTimeout ( struct TimeSpan pRetVal ) {
    HRESULT _hr = put_SponsorshipTimeout(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(442)
inline struct TimeSpan ILease::GetInitialLeaseTime ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_InitialLeaseTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(443)
inline void ILease::PutInitialLeaseTime ( struct TimeSpan pRetVal ) {
    HRESULT _hr = put_InitialLeaseTime(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(444)
inline struct TimeSpan ILease::GetCurrentLeaseTime ( ) {
    struct TimeSpan _result;
    HRESULT _hr = get_CurrentLeaseTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(445)
inline enum LeaseState ILease::GetCurrentState ( ) {
    enum LeaseState _result;
    HRESULT _hr = get_CurrentState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IMessageCtrl wrapper method implementations
//

#pragma implementation_key(446)
inline HRESULT IMessageCtrl::Cancel ( long msToCancel ) {
    HRESULT _hr = raw_Cancel(msToCancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IRemotingFormatter wrapper method implementations
//

#pragma implementation_key(447)
inline _variant_t IRemotingFormatter::Deserialize ( struct _Stream * serializationStream, struct _HeaderHandler * handler ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Deserialize(serializationStream, handler, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(448)
inline HRESULT IRemotingFormatter::Serialize ( struct _Stream * serializationStream, const _variant_t & graph, SAFEARRAY * headers ) {
    HRESULT _hr = raw_Serialize(serializationStream, graph, headers);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IFieldInfo wrapper method implementations
//

#pragma implementation_key(449)
inline SAFEARRAY * IFieldInfo::GetFieldNames ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_FieldNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(450)
inline void IFieldInfo::PutFieldNames ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_FieldNames(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(451)
inline SAFEARRAY * IFieldInfo::GetFieldTypes ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_FieldTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(452)
inline void IFieldInfo::PutFieldTypes ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_FieldTypes(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRemotingTypeInfo wrapper method implementations
//

#pragma implementation_key(453)
inline _bstr_t IRemotingTypeInfo::GettypeName ( ) {
    BSTR _result;
    HRESULT _hr = get_typeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(454)
inline void IRemotingTypeInfo::PuttypeName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_typeName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(455)
inline VARIANT_BOOL IRemotingTypeInfo::CanCastTo ( struct _Type * fromType, const _variant_t & o ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_CanCastTo(fromType, o, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IChannelInfo wrapper method implementations
//

#pragma implementation_key(456)
inline SAFEARRAY * IChannelInfo::GetChannelData ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_ChannelData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(457)
inline void IChannelInfo::PutChannelData ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ChannelData(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IEnvoyInfo wrapper method implementations
//

#pragma implementation_key(458)
inline IMessageSinkPtr IEnvoyInfo::GetEnvoySinks ( ) {
    struct IMessageSink * _result;
    HRESULT _hr = get_EnvoySinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMessageSinkPtr(_result, false);
}

#pragma implementation_key(459)
inline void IEnvoyInfo::PutRefEnvoySinks ( struct IMessageSink * pRetVal ) {
    HRESULT _hr = putref_EnvoySinks(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISoapXsd wrapper method implementations
//

#pragma implementation_key(460)
inline _bstr_t ISoapXsd::GetXsdType ( ) {
    BSTR _result;
    HRESULT _hr = raw_GetXsdType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ITrackingHandler wrapper method implementations
//

#pragma implementation_key(461)
inline HRESULT ITrackingHandler::MarshaledObject ( const _variant_t & obj, struct _ObjRef * or ) {
    HRESULT _hr = raw_MarshaledObject(obj, or);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(462)
inline HRESULT ITrackingHandler::UnmarshaledObject ( const _variant_t & obj, struct _ObjRef * or ) {
    HRESULT _hr = raw_UnmarshaledObject(obj, or);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(463)
inline HRESULT ITrackingHandler::DisconnectedObject ( const _variant_t & obj ) {
    HRESULT _hr = raw_DisconnectedObject(obj);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface INormalizeForIsolatedStorage wrapper method implementations
//

#pragma implementation_key(464)
inline _variant_t INormalizeForIsolatedStorage::Normalize ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Normalize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ISoapMessage wrapper method implementations
//

#pragma implementation_key(465)
inline SAFEARRAY * ISoapMessage::GetParamNames ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_ParamNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(466)
inline void ISoapMessage::PutParamNames ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ParamNames(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(467)
inline SAFEARRAY * ISoapMessage::GetParamValues ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_ParamValues(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(468)
inline void ISoapMessage::PutParamValues ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ParamValues(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(469)
inline SAFEARRAY * ISoapMessage::GetParamTypes ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_ParamTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(470)
inline void ISoapMessage::PutParamTypes ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_ParamTypes(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(471)
inline _bstr_t ISoapMessage::GetMethodName ( ) {
    BSTR _result;
    HRESULT _hr = get_MethodName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(472)
inline void ISoapMessage::PutMethodName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_MethodName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(473)
inline _bstr_t ISoapMessage::GetXmlNameSpace ( ) {
    BSTR _result;
    HRESULT _hr = get_XmlNameSpace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(474)
inline void ISoapMessage::PutXmlNameSpace ( _bstr_t pRetVal ) {
    HRESULT _hr = put_XmlNameSpace(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(475)
inline SAFEARRAY * ISoapMessage::Getheaders ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = get_headers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(476)
inline void ISoapMessage::Putheaders ( SAFEARRAY * pRetVal ) {
    HRESULT _hr = put_headers(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _Object wrapper method implementations
//

#pragma implementation_key(477)
inline _bstr_t _Object::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(478)
inline VARIANT_BOOL _Object::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(479)
inline long _Object::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(480)
inline _TypePtr _Object::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

//
// interface _Exception wrapper method implementations
//

#pragma implementation_key(481)
inline _bstr_t _Exception::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(482)
inline VARIANT_BOOL _Exception::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(483)
inline long _Exception::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(484)
inline _TypePtr _Exception::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(485)
inline _bstr_t _Exception::GetMessage ( ) {
    BSTR _result;
    HRESULT _hr = get_Message(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(486)
inline _ExceptionPtr _Exception::GetBaseException ( ) {
    struct _Exception * _result;
    HRESULT _hr = raw_GetBaseException(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ExceptionPtr(_result, false);
}

#pragma implementation_key(487)
inline _bstr_t _Exception::GetStackTrace ( ) {
    BSTR _result;
    HRESULT _hr = get_StackTrace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(488)
inline _bstr_t _Exception::GetHelpLink ( ) {
    BSTR _result;
    HRESULT _hr = get_HelpLink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(489)
inline void _Exception::PutHelpLink ( _bstr_t pRetVal ) {
    HRESULT _hr = put_HelpLink(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(490)
inline _bstr_t _Exception::GetSource ( ) {
    BSTR _result;
    HRESULT _hr = get_Source(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(491)
inline void _Exception::PutSource ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Source(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(492)
inline HRESULT _Exception::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(493)
inline _ExceptionPtr _Exception::GetInnerException ( ) {
    struct _Exception * _result;
    HRESULT _hr = get_InnerException(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ExceptionPtr(_result, false);
}

#pragma implementation_key(494)
inline _MethodBasePtr _Exception::GetTargetSite ( ) {
    struct _MethodBase * _result;
    HRESULT _hr = get_TargetSite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

//
// interface _Delegate wrapper method implementations
//

#pragma implementation_key(495)
inline _bstr_t _Delegate::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(496)
inline VARIANT_BOOL _Delegate::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(497)
inline long _Delegate::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(498)
inline _TypePtr _Delegate::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(499)
inline SAFEARRAY * _Delegate::GetInvocationList ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetInvocationList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(500)
inline _variant_t _Delegate::Clone ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Clone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(501)
inline HRESULT _Delegate::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(502)
inline _variant_t _Delegate::DynamicInvoke ( SAFEARRAY * args ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_DynamicInvoke(args, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(503)
inline _MethodInfoPtr _Delegate::GetMethod ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = get_Method(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(504)
inline _variant_t _Delegate::GetTarget ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Target(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _Binder wrapper method implementations
//

#pragma implementation_key(505)
inline _bstr_t _Binder::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(506)
inline VARIANT_BOOL _Binder::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(507)
inline long _Binder::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(508)
inline _TypePtr _Binder::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(509)
inline _MethodBasePtr _Binder::BindToMethod ( enum BindingFlags bindingAttr, SAFEARRAY * match, SAFEARRAY * * args, SAFEARRAY * modifiers, struct _CultureInfo * culture, SAFEARRAY * names, VARIANT * state ) {
    struct _MethodBase * _result;
    HRESULT _hr = raw_BindToMethod(bindingAttr, match, args, modifiers, culture, names, state, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

#pragma implementation_key(510)
inline _FieldInfoPtr _Binder::BindToField ( enum BindingFlags bindingAttr, SAFEARRAY * match, const _variant_t & value, struct _CultureInfo * culture ) {
    struct _FieldInfo * _result;
    HRESULT _hr = raw_BindToField(bindingAttr, match, value, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

#pragma implementation_key(511)
inline _MethodBasePtr _Binder::SelectMethod ( enum BindingFlags bindingAttr, SAFEARRAY * match, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodBase * _result;
    HRESULT _hr = raw_SelectMethod(bindingAttr, match, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodBasePtr(_result, false);
}

#pragma implementation_key(512)
inline _PropertyInfoPtr _Binder::SelectProperty ( enum BindingFlags bindingAttr, SAFEARRAY * match, struct _Type * returnType, SAFEARRAY * indexes, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_SelectProperty(bindingAttr, match, returnType, indexes, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(513)
inline _variant_t _Binder::ChangeType ( const _variant_t & value, struct _Type * Type, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_ChangeType(value, Type, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(514)
inline HRESULT _Binder::ReorderArgumentArray ( SAFEARRAY * * args, const _variant_t & state ) {
    HRESULT _hr = raw_ReorderArgumentArray(args, state);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _MemberInfo wrapper method implementations
//

#pragma implementation_key(515)
inline _bstr_t _MemberInfo::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(516)
inline VARIANT_BOOL _MemberInfo::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(517)
inline long _MemberInfo::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(518)
inline _TypePtr _MemberInfo::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(519)
inline enum MemberTypes _MemberInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(520)
inline _bstr_t _MemberInfo::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(521)
inline _TypePtr _MemberInfo::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(522)
inline _TypePtr _MemberInfo::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(523)
inline SAFEARRAY * _MemberInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(524)
inline SAFEARRAY * _MemberInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(525)
inline VARIANT_BOOL _MemberInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _Type wrapper method implementations
//

#pragma implementation_key(526)
inline _bstr_t _Type::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(527)
inline VARIANT_BOOL _Type::Equals ( const _variant_t & o ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(o, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(528)
inline long _Type::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(529)
inline _TypePtr _Type::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(530)
inline enum MemberTypes _Type::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(531)
inline _bstr_t _Type::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(532)
inline _TypePtr _Type::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(533)
inline _TypePtr _Type::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(534)
inline SAFEARRAY * _Type::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(535)
inline SAFEARRAY * _Type::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(536)
inline VARIANT_BOOL _Type::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(537)
inline GUID _Type::GetGuid ( ) {
    GUID _result;
    HRESULT _hr = get_Guid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(538)
inline _NETModulePtr _Type::GetModule ( ) {
    struct _NETModule * _result;
    HRESULT _hr = get_Module(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _NETModulePtr(_result, false);
}

#pragma implementation_key(539)
inline _AssemblyPtr _Type::GetAssembly ( ) {
    struct _Assembly * _result;
    HRESULT _hr = get_Assembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(540)
inline struct RuntimeTypeHandle _Type::GetTypeHandle ( ) {
    struct RuntimeTypeHandle _result;
    HRESULT _hr = get_TypeHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(541)
inline _bstr_t _Type::GetFullName ( ) {
    BSTR _result;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(542)
inline _bstr_t _Type::GetNamespace ( ) {
    BSTR _result;
    HRESULT _hr = get_Namespace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(543)
inline _bstr_t _Type::GetAssemblyQualifiedName ( ) {
    BSTR _result;
    HRESULT _hr = get_AssemblyQualifiedName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(544)
inline long _Type::GetArrayRank ( ) {
    long _result;
    HRESULT _hr = raw_GetArrayRank(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(545)
inline _TypePtr _Type::GetBaseType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_BaseType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(546)
inline SAFEARRAY * _Type::GetConstructors ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetConstructors(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(547)
inline _TypePtr _Type::GetInterface ( _bstr_t name, VARIANT_BOOL ignoreCase ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetInterface(name, ignoreCase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(548)
inline SAFEARRAY * _Type::GetInterfaces ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetInterfaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(549)
inline SAFEARRAY * _Type::FindInterfaces ( struct _TypeFilter * filter, const _variant_t & filterCriteria ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_FindInterfaces(filter, filterCriteria, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(550)
inline _EventInfoPtr _Type::GetEvent ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _EventInfo * _result;
    HRESULT _hr = raw_GetEvent(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EventInfoPtr(_result, false);
}

#pragma implementation_key(551)
inline SAFEARRAY * _Type::GetEvents ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetEvents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(552)
inline SAFEARRAY * _Type::GetEvents_2 ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetEvents_2(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(553)
inline SAFEARRAY * _Type::GetNestedTypes ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetNestedTypes(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(554)
inline _TypePtr _Type::GetNestedType ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetNestedType(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(555)
inline SAFEARRAY * _Type::GetMember ( _bstr_t name, enum MemberTypes Type, enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMember(name, Type, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(556)
inline SAFEARRAY * _Type::GetDefaultMembers ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetDefaultMembers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(557)
inline SAFEARRAY * _Type::FindMembers ( enum MemberTypes MemberType, enum BindingFlags bindingAttr, struct _MemberFilter * filter, const _variant_t & filterCriteria ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_FindMembers(MemberType, bindingAttr, filter, filterCriteria, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(558)
inline _TypePtr _Type::GetElementType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(559)
inline VARIANT_BOOL _Type::IsSubclassOf ( struct _Type * c ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsSubclassOf(c, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(560)
inline VARIANT_BOOL _Type::IsInstanceOfType ( const _variant_t & o ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsInstanceOfType(o, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(561)
inline VARIANT_BOOL _Type::IsAssignableFrom ( struct _Type * c ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsAssignableFrom(c, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(562)
inline struct InterfaceMapping _Type::GetInterfaceMap ( struct _Type * interfaceType ) {
    struct InterfaceMapping _result;
    HRESULT _hr = raw_GetInterfaceMap(interfaceType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(563)
inline _MethodInfoPtr _Type::GetMethod ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod(name, bindingAttr, Binder, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(564)
inline _MethodInfoPtr _Type::GetMethod_2 ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod_2(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(565)
inline SAFEARRAY * _Type::GetMethods ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMethods(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(566)
inline _FieldInfoPtr _Type::GetField ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _FieldInfo * _result;
    HRESULT _hr = raw_GetField(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

#pragma implementation_key(567)
inline SAFEARRAY * _Type::GetFields ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetFields(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(568)
inline _PropertyInfoPtr _Type::GetProperty ( _bstr_t name, enum BindingFlags bindingAttr ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(569)
inline _PropertyInfoPtr _Type::GetProperty_2 ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, struct _Type * returnType, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty_2(name, bindingAttr, Binder, returnType, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(570)
inline SAFEARRAY * _Type::GetProperties ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetProperties(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(571)
inline SAFEARRAY * _Type::GetMember_2 ( _bstr_t name, enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMember_2(name, bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(572)
inline SAFEARRAY * _Type::GetMembers ( enum BindingFlags bindingAttr ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMembers(bindingAttr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(573)
inline _variant_t _Type::InvokeMember ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args, SAFEARRAY * modifiers, struct _CultureInfo * culture, SAFEARRAY * namedParameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember(name, invokeAttr, Binder, Target, args, modifiers, culture, namedParameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(574)
inline _TypePtr _Type::GetUnderlyingSystemType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_UnderlyingSystemType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(575)
inline _variant_t _Type::InvokeMember_2 ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember_2(name, invokeAttr, Binder, Target, args, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(576)
inline _variant_t _Type::InvokeMember_3 ( _bstr_t name, enum BindingFlags invokeAttr, struct _Binder * Binder, const _variant_t & Target, SAFEARRAY * args ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InvokeMember_3(name, invokeAttr, Binder, Target, args, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(577)
inline _ConstructorInfoPtr _Type::GetConstructor ( enum BindingFlags bindingAttr, struct _Binder * Binder, enum CallingConventions callConvention, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _ConstructorInfo * _result;
    HRESULT _hr = raw_GetConstructor(bindingAttr, Binder, callConvention, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

#pragma implementation_key(578)
inline _ConstructorInfoPtr _Type::GetConstructor_2 ( enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _ConstructorInfo * _result;
    HRESULT _hr = raw_GetConstructor_2(bindingAttr, Binder, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

#pragma implementation_key(579)
inline _ConstructorInfoPtr _Type::GetConstructor_3 ( SAFEARRAY * types ) {
    struct _ConstructorInfo * _result;
    HRESULT _hr = raw_GetConstructor_3(types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

#pragma implementation_key(580)
inline SAFEARRAY * _Type::GetConstructors_2 ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetConstructors_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(581)
inline _ConstructorInfoPtr _Type::GetTypeInitializer ( ) {
    struct _ConstructorInfo * _result;
    HRESULT _hr = get_TypeInitializer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ConstructorInfoPtr(_result, false);
}

#pragma implementation_key(582)
inline _MethodInfoPtr _Type::GetMethod_3 ( _bstr_t name, enum BindingFlags bindingAttr, struct _Binder * Binder, enum CallingConventions callConvention, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod_3(name, bindingAttr, Binder, callConvention, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(583)
inline _MethodInfoPtr _Type::GetMethod_4 ( _bstr_t name, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod_4(name, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(584)
inline _MethodInfoPtr _Type::GetMethod_5 ( _bstr_t name, SAFEARRAY * types ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod_5(name, types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(585)
inline _MethodInfoPtr _Type::GetMethod_6 ( _bstr_t name ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetMethod_6(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(586)
inline SAFEARRAY * _Type::GetMethods_2 ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMethods_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(587)
inline _FieldInfoPtr _Type::GetField_2 ( _bstr_t name ) {
    struct _FieldInfo * _result;
    HRESULT _hr = raw_GetField_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldInfoPtr(_result, false);
}

#pragma implementation_key(588)
inline SAFEARRAY * _Type::GetFields_2 ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetFields_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(589)
inline _TypePtr _Type::GetInterface_2 ( _bstr_t name ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetInterface_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(590)
inline _EventInfoPtr _Type::GetEvent_2 ( _bstr_t name ) {
    struct _EventInfo * _result;
    HRESULT _hr = raw_GetEvent_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EventInfoPtr(_result, false);
}

#pragma implementation_key(591)
inline _PropertyInfoPtr _Type::GetProperty_3 ( _bstr_t name, struct _Type * returnType, SAFEARRAY * types, SAFEARRAY * modifiers ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty_3(name, returnType, types, modifiers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(592)
inline _PropertyInfoPtr _Type::GetProperty_4 ( _bstr_t name, struct _Type * returnType, SAFEARRAY * types ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty_4(name, returnType, types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(593)
inline _PropertyInfoPtr _Type::GetProperty_5 ( _bstr_t name, SAFEARRAY * types ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty_5(name, types, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(594)
inline _PropertyInfoPtr _Type::GetProperty_6 ( _bstr_t name, struct _Type * returnType ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty_6(name, returnType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(595)
inline _PropertyInfoPtr _Type::GetProperty_7 ( _bstr_t name ) {
    struct _PropertyInfo * _result;
    HRESULT _hr = raw_GetProperty_7(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _PropertyInfoPtr(_result, false);
}

#pragma implementation_key(596)
inline SAFEARRAY * _Type::GetProperties_2 ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetProperties_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(597)
inline SAFEARRAY * _Type::GetNestedTypes_2 ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetNestedTypes_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(598)
inline _TypePtr _Type::GetNestedType_2 ( _bstr_t name ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetNestedType_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(599)
inline SAFEARRAY * _Type::GetMember_3 ( _bstr_t name ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMember_3(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(600)
inline SAFEARRAY * _Type::GetMembers_2 ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetMembers_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(601)
inline enum TypeAttributes _Type::GetAttributes ( ) {
    enum TypeAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(602)
inline VARIANT_BOOL _Type::GetIsNotPublic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNotPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(603)
inline VARIANT_BOOL _Type::GetIsPublic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(604)
inline VARIANT_BOOL _Type::GetIsNestedPublic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNestedPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(605)
inline VARIANT_BOOL _Type::GetIsNestedPrivate ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNestedPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(606)
inline VARIANT_BOOL _Type::GetIsNestedFamily ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNestedFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(607)
inline VARIANT_BOOL _Type::GetIsNestedAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNestedAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(608)
inline VARIANT_BOOL _Type::GetIsNestedFamANDAssem ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNestedFamANDAssem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(609)
inline VARIANT_BOOL _Type::GetIsNestedFamORAssem ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNestedFamORAssem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(610)
inline VARIANT_BOOL _Type::GetIsAutoLayout ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAutoLayout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(611)
inline VARIANT_BOOL _Type::GetIsLayoutSequential ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsLayoutSequential(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(612)
inline VARIANT_BOOL _Type::GetIsExplicitLayout ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsExplicitLayout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(613)
inline VARIANT_BOOL _Type::GetIsClass ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(614)
inline VARIANT_BOOL _Type::GetIsInterface ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsInterface(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(615)
inline VARIANT_BOOL _Type::GetIsValueType ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsValueType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(616)
inline VARIANT_BOOL _Type::GetIsAbstract ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(617)
inline VARIANT_BOOL _Type::GetIsSealed ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSealed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(618)
inline VARIANT_BOOL _Type::GetIsEnum ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(619)
inline VARIANT_BOOL _Type::GetIsSpecialName ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(620)
inline VARIANT_BOOL _Type::GetIsImport ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsImport(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(621)
inline VARIANT_BOOL _Type::GetIsSerializable ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSerializable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(622)
inline VARIANT_BOOL _Type::GetIsAnsiClass ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAnsiClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(623)
inline VARIANT_BOOL _Type::GetIsUnicodeClass ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsUnicodeClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(624)
inline VARIANT_BOOL _Type::GetIsAutoClass ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAutoClass(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(625)
inline VARIANT_BOOL _Type::GetIsArray ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(626)
inline VARIANT_BOOL _Type::GetIsByRef ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsByRef(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(627)
inline VARIANT_BOOL _Type::GetIsPointer ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPointer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(628)
inline VARIANT_BOOL _Type::GetIsPrimitive ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPrimitive(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(629)
inline VARIANT_BOOL _Type::GetIsCOMObject ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsCOMObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(630)
inline VARIANT_BOOL _Type::GetHasElementType ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_HasElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(631)
inline VARIANT_BOOL _Type::GetIsContextful ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsContextful(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(632)
inline VARIANT_BOOL _Type::GetIsMarshalByRef ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsMarshalByRef(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(633)
inline VARIANT_BOOL _Type::Equals_2 ( struct _Type * o ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals_2(o, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _Assembly wrapper method implementations
//

#pragma implementation_key(634)
inline _bstr_t _Assembly::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(635)
inline VARIANT_BOOL _Assembly::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(636)
inline long _Assembly::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(637)
inline _TypePtr _Assembly::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(638)
inline _bstr_t _Assembly::GetCodeBase ( ) {
    BSTR _result;
    HRESULT _hr = get_CodeBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(639)
inline _bstr_t _Assembly::GetEscapedCodeBase ( ) {
    BSTR _result;
    HRESULT _hr = get_EscapedCodeBase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(640)
inline _AssemblyNamePtr _Assembly::GetName ( ) {
    struct _AssemblyName * _result;
    HRESULT _hr = raw_GetName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyNamePtr(_result, false);
}

#pragma implementation_key(641)
inline _AssemblyNamePtr _Assembly::GetName_2 ( VARIANT_BOOL copiedName ) {
    struct _AssemblyName * _result;
    HRESULT _hr = raw_GetName_2(copiedName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyNamePtr(_result, false);
}

#pragma implementation_key(642)
inline _bstr_t _Assembly::GetFullName ( ) {
    BSTR _result;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(643)
inline _MethodInfoPtr _Assembly::GetEntryPoint ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = get_EntryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(644)
inline _TypePtr _Assembly::GetType_2 ( _bstr_t name ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(645)
inline _TypePtr _Assembly::GetType_3 ( _bstr_t name, VARIANT_BOOL throwOnError ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType_3(name, throwOnError, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(646)
inline SAFEARRAY * _Assembly::GetExportedTypes ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetExportedTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(647)
inline SAFEARRAY * _Assembly::GetTypes ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(648)
inline _StreamPtr _Assembly::GetManifestResourceStream ( struct _Type * Type, _bstr_t name ) {
    struct _Stream * _result;
    HRESULT _hr = raw_GetManifestResourceStream(Type, name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

#pragma implementation_key(649)
inline _StreamPtr _Assembly::GetManifestResourceStream_2 ( _bstr_t name ) {
    struct _Stream * _result;
    HRESULT _hr = raw_GetManifestResourceStream_2(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _StreamPtr(_result, false);
}

#pragma implementation_key(650)
inline _FileStreamPtr _Assembly::GetFile ( _bstr_t name ) {
    struct _FileStream * _result;
    HRESULT _hr = raw_GetFile(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FileStreamPtr(_result, false);
}

#pragma implementation_key(651)
inline SAFEARRAY * _Assembly::GetFiles ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(652)
inline SAFEARRAY * _Assembly::GetFiles_2 ( VARIANT_BOOL getResourceModules ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetFiles_2(getResourceModules, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(653)
inline SAFEARRAY * _Assembly::GetManifestResourceNames ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetManifestResourceNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(654)
inline _ManifestResourceInfoPtr _Assembly::GetManifestResourceInfo ( _bstr_t resourceName ) {
    struct _ManifestResourceInfo * _result;
    HRESULT _hr = raw_GetManifestResourceInfo(resourceName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ManifestResourceInfoPtr(_result, false);
}

#pragma implementation_key(655)
inline _bstr_t _Assembly::GetLocation ( ) {
    BSTR _result;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(656)
inline _EvidencePtr _Assembly::GetEvidence ( ) {
    struct _Evidence * _result;
    HRESULT _hr = get_Evidence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _EvidencePtr(_result, false);
}

#pragma implementation_key(657)
inline SAFEARRAY * _Assembly::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(658)
inline SAFEARRAY * _Assembly::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(659)
inline VARIANT_BOOL _Assembly::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(660)
inline HRESULT _Assembly::GetObjectData ( struct _SerializationInfo * info, struct StreamingContext Context ) {
    HRESULT _hr = raw_GetObjectData(info, Context);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(661)
inline HRESULT _Assembly::add_ModuleResolve ( struct _ModuleResolveEventHandler * value ) {
    HRESULT _hr = raw_add_ModuleResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(662)
inline HRESULT _Assembly::remove_ModuleResolve ( struct _ModuleResolveEventHandler * value ) {
    HRESULT _hr = raw_remove_ModuleResolve(value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(663)
inline _TypePtr _Assembly::GetType_4 ( _bstr_t name, VARIANT_BOOL throwOnError, VARIANT_BOOL ignoreCase ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType_4(name, throwOnError, ignoreCase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(664)
inline _AssemblyPtr _Assembly::GetSatelliteAssembly ( struct _CultureInfo * culture ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_GetSatelliteAssembly(culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(665)
inline _AssemblyPtr _Assembly::GetSatelliteAssembly_2 ( struct _CultureInfo * culture, struct _Version * Version ) {
    struct _Assembly * _result;
    HRESULT _hr = raw_GetSatelliteAssembly_2(culture, Version, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _AssemblyPtr(_result, false);
}

#pragma implementation_key(666)
inline _NETModulePtr _Assembly::LoadModule ( _bstr_t moduleName, SAFEARRAY * rawModule ) {
    struct _NETModule * _result;
    HRESULT _hr = raw_LoadModule(moduleName, rawModule, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _NETModulePtr(_result, false);
}

#pragma implementation_key(667)
inline _NETModulePtr _Assembly::LoadModule_2 ( _bstr_t moduleName, SAFEARRAY * rawModule, SAFEARRAY * rawSymbolStore ) {
    struct _NETModule * _result;
    HRESULT _hr = raw_LoadModule_2(moduleName, rawModule, rawSymbolStore, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _NETModulePtr(_result, false);
}

#pragma implementation_key(668)
inline _variant_t _Assembly::CreateInstance ( _bstr_t typeName ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CreateInstance(typeName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(669)
inline _variant_t _Assembly::CreateInstance_2 ( _bstr_t typeName, VARIANT_BOOL ignoreCase ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CreateInstance_2(typeName, ignoreCase, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(670)
inline _variant_t _Assembly::CreateInstance_3 ( _bstr_t typeName, VARIANT_BOOL ignoreCase, enum BindingFlags bindingAttr, struct _Binder * Binder, SAFEARRAY * args, struct _CultureInfo * culture, SAFEARRAY * activationAttributes ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CreateInstance_3(typeName, ignoreCase, bindingAttr, Binder, args, culture, activationAttributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(671)
inline SAFEARRAY * _Assembly::GetLoadedModules ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetLoadedModules(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(672)
inline SAFEARRAY * _Assembly::GetLoadedModules_2 ( VARIANT_BOOL getResourceModules ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetLoadedModules_2(getResourceModules, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(673)
inline SAFEARRAY * _Assembly::GetModules ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetModules(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(674)
inline SAFEARRAY * _Assembly::GetModules_2 ( VARIANT_BOOL getResourceModules ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetModules_2(getResourceModules, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(675)
inline _NETModulePtr _Assembly::GetModule ( _bstr_t name ) {
    struct _NETModule * _result;
    HRESULT _hr = raw_GetModule(name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _NETModulePtr(_result, false);
}

#pragma implementation_key(676)
inline SAFEARRAY * _Assembly::GetReferencedAssemblies ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetReferencedAssemblies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(677)
inline VARIANT_BOOL _Assembly::GetGlobalAssemblyCache ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_GlobalAssemblyCache(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _MethodBase wrapper method implementations
//

#pragma implementation_key(678)
inline _bstr_t _MethodBase::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(679)
inline VARIANT_BOOL _MethodBase::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(680)
inline long _MethodBase::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(681)
inline _TypePtr _MethodBase::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(682)
inline enum MemberTypes _MethodBase::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(683)
inline _bstr_t _MethodBase::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(684)
inline _TypePtr _MethodBase::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(685)
inline _TypePtr _MethodBase::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(686)
inline SAFEARRAY * _MethodBase::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(687)
inline SAFEARRAY * _MethodBase::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(688)
inline VARIANT_BOOL _MethodBase::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(689)
inline SAFEARRAY * _MethodBase::GetParameters ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(690)
inline enum MethodImplAttributes _MethodBase::GetMethodImplementationFlags ( ) {
    enum MethodImplAttributes _result;
    HRESULT _hr = raw_GetMethodImplementationFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(691)
inline struct RuntimeMethodHandle _MethodBase::GetMethodHandle ( ) {
    struct RuntimeMethodHandle _result;
    HRESULT _hr = get_MethodHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(692)
inline enum MethodAttributes _MethodBase::GetAttributes ( ) {
    enum MethodAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(693)
inline enum CallingConventions _MethodBase::GetCallingConvention ( ) {
    enum CallingConventions _result;
    HRESULT _hr = get_CallingConvention(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(694)
inline _variant_t _MethodBase::Invoke_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_2(obj, invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(695)
inline VARIANT_BOOL _MethodBase::GetIsPublic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(696)
inline VARIANT_BOOL _MethodBase::GetIsPrivate ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(697)
inline VARIANT_BOOL _MethodBase::GetIsFamily ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(698)
inline VARIANT_BOOL _MethodBase::GetIsAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(699)
inline VARIANT_BOOL _MethodBase::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(700)
inline VARIANT_BOOL _MethodBase::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(701)
inline VARIANT_BOOL _MethodBase::GetIsStatic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(702)
inline VARIANT_BOOL _MethodBase::GetIsFinal ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFinal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(703)
inline VARIANT_BOOL _MethodBase::GetIsVirtual ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsVirtual(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(704)
inline VARIANT_BOOL _MethodBase::GetIsHideBySig ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsHideBySig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(705)
inline VARIANT_BOOL _MethodBase::GetIsAbstract ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(706)
inline VARIANT_BOOL _MethodBase::GetIsSpecialName ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(707)
inline VARIANT_BOOL _MethodBase::GetIsConstructor ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsConstructor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(708)
inline _variant_t _MethodBase::Invoke_3 ( const _variant_t & obj, SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_3(obj, parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _ConstructorInfo wrapper method implementations
//

#pragma implementation_key(709)
inline _bstr_t _ConstructorInfo::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(710)
inline VARIANT_BOOL _ConstructorInfo::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(711)
inline long _ConstructorInfo::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(712)
inline _TypePtr _ConstructorInfo::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(713)
inline enum MemberTypes _ConstructorInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(714)
inline _bstr_t _ConstructorInfo::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(715)
inline _TypePtr _ConstructorInfo::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(716)
inline _TypePtr _ConstructorInfo::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(717)
inline SAFEARRAY * _ConstructorInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(718)
inline SAFEARRAY * _ConstructorInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(719)
inline VARIANT_BOOL _ConstructorInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(720)
inline SAFEARRAY * _ConstructorInfo::GetParameters ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(721)
inline enum MethodImplAttributes _ConstructorInfo::GetMethodImplementationFlags ( ) {
    enum MethodImplAttributes _result;
    HRESULT _hr = raw_GetMethodImplementationFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(722)
inline struct RuntimeMethodHandle _ConstructorInfo::GetMethodHandle ( ) {
    struct RuntimeMethodHandle _result;
    HRESULT _hr = get_MethodHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(723)
inline enum MethodAttributes _ConstructorInfo::GetAttributes ( ) {
    enum MethodAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(724)
inline enum CallingConventions _ConstructorInfo::GetCallingConvention ( ) {
    enum CallingConventions _result;
    HRESULT _hr = get_CallingConvention(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(725)
inline _variant_t _ConstructorInfo::Invoke_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_2(obj, invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(726)
inline VARIANT_BOOL _ConstructorInfo::GetIsPublic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(727)
inline VARIANT_BOOL _ConstructorInfo::GetIsPrivate ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(728)
inline VARIANT_BOOL _ConstructorInfo::GetIsFamily ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(729)
inline VARIANT_BOOL _ConstructorInfo::GetIsAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(730)
inline VARIANT_BOOL _ConstructorInfo::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(731)
inline VARIANT_BOOL _ConstructorInfo::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(732)
inline VARIANT_BOOL _ConstructorInfo::GetIsStatic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(733)
inline VARIANT_BOOL _ConstructorInfo::GetIsFinal ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFinal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(734)
inline VARIANT_BOOL _ConstructorInfo::GetIsVirtual ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsVirtual(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(735)
inline VARIANT_BOOL _ConstructorInfo::GetIsHideBySig ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsHideBySig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(736)
inline VARIANT_BOOL _ConstructorInfo::GetIsAbstract ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(737)
inline VARIANT_BOOL _ConstructorInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(738)
inline VARIANT_BOOL _ConstructorInfo::GetIsConstructor ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsConstructor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(739)
inline _variant_t _ConstructorInfo::Invoke_3 ( const _variant_t & obj, SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_3(obj, parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(740)
inline _variant_t _ConstructorInfo::Invoke_4 ( enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_4(invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(741)
inline _variant_t _ConstructorInfo::Invoke_5 ( SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_5(parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _EventInfo wrapper method implementations
//

#pragma implementation_key(742)
inline _bstr_t _EventInfo::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(743)
inline VARIANT_BOOL _EventInfo::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(744)
inline long _EventInfo::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(745)
inline _TypePtr _EventInfo::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(746)
inline enum MemberTypes _EventInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(747)
inline _bstr_t _EventInfo::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(748)
inline _TypePtr _EventInfo::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(749)
inline _TypePtr _EventInfo::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(750)
inline SAFEARRAY * _EventInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(751)
inline SAFEARRAY * _EventInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(752)
inline VARIANT_BOOL _EventInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(753)
inline _MethodInfoPtr _EventInfo::GetAddMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetAddMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(754)
inline _MethodInfoPtr _EventInfo::GetRemoveMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetRemoveMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(755)
inline _MethodInfoPtr _EventInfo::GetRaiseMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetRaiseMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(756)
inline enum EventAttributes _EventInfo::GetAttributes ( ) {
    enum EventAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(757)
inline _MethodInfoPtr _EventInfo::GetAddMethod_2 ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetAddMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(758)
inline _MethodInfoPtr _EventInfo::GetRemoveMethod_2 ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetRemoveMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(759)
inline _MethodInfoPtr _EventInfo::GetRaiseMethod_2 ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetRaiseMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(760)
inline HRESULT _EventInfo::AddEventHandler ( const _variant_t & Target, struct _Delegate * handler ) {
    HRESULT _hr = raw_AddEventHandler(Target, handler);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(761)
inline HRESULT _EventInfo::RemoveEventHandler ( const _variant_t & Target, struct _Delegate * handler ) {
    HRESULT _hr = raw_RemoveEventHandler(Target, handler);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(762)
inline _TypePtr _EventInfo::GetEventHandlerType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_EventHandlerType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(763)
inline VARIANT_BOOL _EventInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(764)
inline VARIANT_BOOL _EventInfo::GetIsMulticast ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsMulticast(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _FieldInfo wrapper method implementations
//

#pragma implementation_key(765)
inline _bstr_t _FieldInfo::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(766)
inline VARIANT_BOOL _FieldInfo::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(767)
inline long _FieldInfo::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(768)
inline _TypePtr _FieldInfo::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(769)
inline enum MemberTypes _FieldInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(770)
inline _bstr_t _FieldInfo::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(771)
inline _TypePtr _FieldInfo::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(772)
inline _TypePtr _FieldInfo::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(773)
inline SAFEARRAY * _FieldInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(774)
inline SAFEARRAY * _FieldInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(775)
inline VARIANT_BOOL _FieldInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(776)
inline _TypePtr _FieldInfo::GetFieldType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_FieldType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(777)
inline _variant_t _FieldInfo::GetValue ( const _variant_t & obj ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(778)
inline _variant_t _FieldInfo::GetValueDirect ( const _variant_t & obj ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValueDirect(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(779)
inline HRESULT _FieldInfo::SetValue ( const _variant_t & obj, const _variant_t & value, enum BindingFlags invokeAttr, struct _Binder * Binder, struct _CultureInfo * culture ) {
    HRESULT _hr = raw_SetValue(obj, value, invokeAttr, Binder, culture);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(780)
inline HRESULT _FieldInfo::SetValueDirect ( const _variant_t & obj, const _variant_t & value ) {
    HRESULT _hr = raw_SetValueDirect(obj, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(781)
inline struct RuntimeFieldHandle _FieldInfo::GetFieldHandle ( ) {
    struct RuntimeFieldHandle _result;
    HRESULT _hr = get_FieldHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(782)
inline enum FieldAttributes _FieldInfo::GetAttributes ( ) {
    enum FieldAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(783)
inline HRESULT _FieldInfo::SetValue_2 ( const _variant_t & obj, const _variant_t & value ) {
    HRESULT _hr = raw_SetValue_2(obj, value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(784)
inline VARIANT_BOOL _FieldInfo::GetIsPublic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(785)
inline VARIANT_BOOL _FieldInfo::GetIsPrivate ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(786)
inline VARIANT_BOOL _FieldInfo::GetIsFamily ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(787)
inline VARIANT_BOOL _FieldInfo::GetIsAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(788)
inline VARIANT_BOOL _FieldInfo::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(789)
inline VARIANT_BOOL _FieldInfo::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(790)
inline VARIANT_BOOL _FieldInfo::GetIsStatic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(791)
inline VARIANT_BOOL _FieldInfo::GetIsInitOnly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsInitOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(792)
inline VARIANT_BOOL _FieldInfo::GetIsLiteral ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsLiteral(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(793)
inline VARIANT_BOOL _FieldInfo::GetIsNotSerialized ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsNotSerialized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(794)
inline VARIANT_BOOL _FieldInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(795)
inline VARIANT_BOOL _FieldInfo::GetIsPinvokeImpl ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPinvokeImpl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _MethodInfo wrapper method implementations
//

#pragma implementation_key(796)
inline _bstr_t _MethodInfo::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(797)
inline VARIANT_BOOL _MethodInfo::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(798)
inline long _MethodInfo::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(799)
inline _TypePtr _MethodInfo::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(800)
inline enum MemberTypes _MethodInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(801)
inline _bstr_t _MethodInfo::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(802)
inline _TypePtr _MethodInfo::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(803)
inline _TypePtr _MethodInfo::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(804)
inline SAFEARRAY * _MethodInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(805)
inline SAFEARRAY * _MethodInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(806)
inline VARIANT_BOOL _MethodInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(807)
inline SAFEARRAY * _MethodInfo::GetParameters ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(808)
inline enum MethodImplAttributes _MethodInfo::GetMethodImplementationFlags ( ) {
    enum MethodImplAttributes _result;
    HRESULT _hr = raw_GetMethodImplementationFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(809)
inline struct RuntimeMethodHandle _MethodInfo::GetMethodHandle ( ) {
    struct RuntimeMethodHandle _result;
    HRESULT _hr = get_MethodHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(810)
inline enum MethodAttributes _MethodInfo::GetAttributes ( ) {
    enum MethodAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(811)
inline enum CallingConventions _MethodInfo::GetCallingConvention ( ) {
    enum CallingConventions _result;
    HRESULT _hr = get_CallingConvention(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(812)
inline _variant_t _MethodInfo::Invoke_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * parameters, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_2(obj, invokeAttr, Binder, parameters, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(813)
inline VARIANT_BOOL _MethodInfo::GetIsPublic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPublic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(814)
inline VARIANT_BOOL _MethodInfo::GetIsPrivate ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsPrivate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(815)
inline VARIANT_BOOL _MethodInfo::GetIsFamily ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamily(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(816)
inline VARIANT_BOOL _MethodInfo::GetIsAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(817)
inline VARIANT_BOOL _MethodInfo::GetIsFamilyAndAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyAndAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(818)
inline VARIANT_BOOL _MethodInfo::GetIsFamilyOrAssembly ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFamilyOrAssembly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(819)
inline VARIANT_BOOL _MethodInfo::GetIsStatic ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsStatic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(820)
inline VARIANT_BOOL _MethodInfo::GetIsFinal ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsFinal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(821)
inline VARIANT_BOOL _MethodInfo::GetIsVirtual ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsVirtual(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(822)
inline VARIANT_BOOL _MethodInfo::GetIsHideBySig ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsHideBySig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(823)
inline VARIANT_BOOL _MethodInfo::GetIsAbstract ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsAbstract(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(824)
inline VARIANT_BOOL _MethodInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(825)
inline VARIANT_BOOL _MethodInfo::GetIsConstructor ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsConstructor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(826)
inline _variant_t _MethodInfo::Invoke_3 ( const _variant_t & obj, SAFEARRAY * parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Invoke_3(obj, parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(827)
inline _TypePtr _MethodInfo::GetreturnType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_returnType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(828)
inline ICustomAttributeProviderPtr _MethodInfo::GetReturnTypeCustomAttributes ( ) {
    struct ICustomAttributeProvider * _result;
    HRESULT _hr = get_ReturnTypeCustomAttributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICustomAttributeProviderPtr(_result, false);
}

#pragma implementation_key(829)
inline _MethodInfoPtr _MethodInfo::GetBaseDefinition ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetBaseDefinition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

//
// interface _PropertyInfo wrapper method implementations
//

#pragma implementation_key(830)
inline _bstr_t _PropertyInfo::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(831)
inline VARIANT_BOOL _PropertyInfo::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(832)
inline long _PropertyInfo::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(833)
inline _TypePtr _PropertyInfo::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(834)
inline enum MemberTypes _PropertyInfo::GetMemberType ( ) {
    enum MemberTypes _result;
    HRESULT _hr = get_MemberType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(835)
inline _bstr_t _PropertyInfo::Getname ( ) {
    BSTR _result;
    HRESULT _hr = get_name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(836)
inline _TypePtr _PropertyInfo::GetDeclaringType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_DeclaringType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(837)
inline _TypePtr _PropertyInfo::GetReflectedType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_ReflectedType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(838)
inline SAFEARRAY * _PropertyInfo::GetCustomAttributes ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(839)
inline SAFEARRAY * _PropertyInfo::GetCustomAttributes_2 ( VARIANT_BOOL inherit ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetCustomAttributes_2(inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(840)
inline VARIANT_BOOL _PropertyInfo::IsDefined ( struct _Type * attributeType, VARIANT_BOOL inherit ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_IsDefined(attributeType, inherit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(841)
inline _TypePtr _PropertyInfo::GetPropertyType ( ) {
    struct _Type * _result;
    HRESULT _hr = get_PropertyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(842)
inline _variant_t _PropertyInfo::GetValue ( const _variant_t & obj, SAFEARRAY * index ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(obj, index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(843)
inline _variant_t _PropertyInfo::GetValue_2 ( const _variant_t & obj, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * index, struct _CultureInfo * culture ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue_2(obj, invokeAttr, Binder, index, culture, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(844)
inline HRESULT _PropertyInfo::SetValue ( const _variant_t & obj, const _variant_t & value, SAFEARRAY * index ) {
    HRESULT _hr = raw_SetValue(obj, value, index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(845)
inline HRESULT _PropertyInfo::SetValue_2 ( const _variant_t & obj, const _variant_t & value, enum BindingFlags invokeAttr, struct _Binder * Binder, SAFEARRAY * index, struct _CultureInfo * culture ) {
    HRESULT _hr = raw_SetValue_2(obj, value, invokeAttr, Binder, index, culture);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(846)
inline SAFEARRAY * _PropertyInfo::GetAccessors ( VARIANT_BOOL nonPublic ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetAccessors(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(847)
inline _MethodInfoPtr _PropertyInfo::GetGetMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetGetMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(848)
inline _MethodInfoPtr _PropertyInfo::GetSetMethod ( VARIANT_BOOL nonPublic ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetSetMethod(nonPublic, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(849)
inline SAFEARRAY * _PropertyInfo::GetIndexParameters ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetIndexParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(850)
inline enum PropertyAttributes _PropertyInfo::GetAttributes ( ) {
    enum PropertyAttributes _result;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(851)
inline VARIANT_BOOL _PropertyInfo::GetCanRead ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_CanRead(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(852)
inline VARIANT_BOOL _PropertyInfo::GetCanWrite ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_CanWrite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(853)
inline SAFEARRAY * _PropertyInfo::GetAccessors_2 ( ) {
    SAFEARRAY * _result;
    HRESULT _hr = raw_GetAccessors_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(854)
inline _MethodInfoPtr _PropertyInfo::GetGetMethod_2 ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetGetMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(855)
inline _MethodInfoPtr _PropertyInfo::GetSetMethod_2 ( ) {
    struct _MethodInfo * _result;
    HRESULT _hr = raw_GetSetMethod_2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _MethodInfoPtr(_result, false);
}

#pragma implementation_key(856)
inline VARIANT_BOOL _PropertyInfo::GetIsSpecialName ( ) {
    VARIANT_BOOL _result;
    HRESULT _hr = get_IsSpecialName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _ObjectHandle wrapper method implementations
//

#pragma implementation_key(857)
inline _bstr_t _ObjectHandle::GetToString ( ) {
    BSTR _result;
    HRESULT _hr = get_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(858)
inline VARIANT_BOOL _ObjectHandle::Equals ( const _variant_t & obj ) {
    VARIANT_BOOL _result;
    HRESULT _hr = raw_Equals(obj, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(859)
inline long _ObjectHandle::GetHashCode ( ) {
    long _result;
    HRESULT _hr = raw_GetHashCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(860)
inline _TypePtr _ObjectHandle::GetType ( ) {
    struct _Type * _result;
    HRESULT _hr = raw_GetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TypePtr(_result, false);
}

#pragma implementation_key(861)
inline _variant_t _ObjectHandle::GetLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(862)
inline _variant_t _ObjectHandle::InitializeLifetimeService ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_InitializeLifetimeService(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(863)
inline _ObjRefPtr _ObjectHandle::CreateObjRef ( struct _Type * requestedType ) {
    struct _ObjRef * _result;
    HRESULT _hr = raw_CreateObjRef(requestedType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _ObjRefPtr(_result, false);
}

#pragma implementation_key(864)
inline _variant_t _ObjectHandle::Unwrap ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Unwrap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}
